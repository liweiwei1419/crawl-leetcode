1,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个整数数组和一个目标值，找出数组中和为目标值的<strong>两个</strong>数。</p>
<p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p>
<p><strong>示例:</strong></p>
<pre>给定 nums = [2, 7, 11, 15], target = 9

因为 nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9
所以返回 [<strong>0, 1</strong>]
</pre>
</div></div>"
2,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定两个<strong>非空</strong>链表来表示两个非负整数。位数按照<strong>逆序</strong>方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
<strong>输出：</strong>7 -&gt; 0 -&gt; 8
<strong>原因：</strong>342 + 465 = 807
</pre>
</div></div>"
3,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串，找出不含有重复字符的<strong>最长子串</strong>的长度。</p>
<p><strong>示例：</strong></p>
<p>给定 <code>""abcabcbb""</code> ，没有重复字符的最长子串是 <code>""abc""</code> ，那么长度就是3。</p>
<p>给定 <code>""bbbbb""</code> ，最长的子串就是 <code>""b""</code> ，长度是1。</p>
<p>给定 <code>""pwwkew""</code> ，最长子串是 <code>""wke""</code> ，长度是3。请注意答案必须是一个<strong>子串</strong>，<code>""pwke""</code> 是 <em>子序列  </em>而不是子串。</p>
</div></div>"
4,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定两个大小为 m 和 n 的有序数组 <strong>nums1 </strong>和 <strong>nums2 </strong>。</p>
<p>请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。</p>
<p><strong>示例 1:</strong></p>
<pre>nums1 = [1, 3]
nums2 = [2]

中位数是 2.0
</pre>
<p><strong>示例 2:</strong></p>
<pre>nums1 = [1, 2]
nums2 = [3, 4]

中位数是 (2 + 3)/2 = 2.5
</pre>
</div></div>"
5,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串 <strong>s</strong>，找到 <strong>s</strong> 中最长的回文子串。你可以假设 <strong>s </strong>的最大长度为1000。</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入:</strong> ""babad""
<strong>输出:</strong> ""bab""
<strong>注意:</strong> ""aba""也是一个有效答案。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入:</strong> ""cbbd""
<strong>输出:</strong> ""bb""
</pre>
</div></div>"
6,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>将字符串 <code>""PAYPALISHIRING""</code> 以Z字形排列成给定的行数：</p>
<pre>P   A   H   N
A P L S I I G
Y   I   R
</pre>
<p>之后从左往右，逐行读取字符：<code>""PAHNAPLSIIGYIR""</code></p>
<p>实现一个将字符串进行指定行数变换的函数:</p>
<pre>string convert(string s, int numRows);</pre>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> s = ""PAYPALISHIRING"", numRows = 3
<strong>输出:</strong> ""PAHNAPLSIIGYIR""
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> s = ""PAYPALISHIRING"", numRows = 4
<strong>输出:</strong> ""PINALSIGYAHRPI""
<strong>解释:</strong>

P     I    N
A   L S  I G
Y A   H R
P     I</pre>
</div></div>"
7,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个 32 位有符号整数，将整数中的数字进行反转。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 123
<strong>输出:</strong> 321
</pre>
<p><strong> 示例 2:</strong></p>
<pre><strong>输入:</strong> -123
<strong>输出:</strong> -321
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> 120
<strong>输出:</strong> 21
</pre>
<p><strong>注意:</strong></p>
<p>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2<sup>31</sup>,  2<sup>31 </sup>− 1]。根据这个假设，如果反转后的整数溢出，则返回 0。</p>
</div></div>"
8,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>实现 <code>atoi</code>，将字符串转为整数。</p>
<p>在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。</p>
<p>当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。</p>
<p>若函数不能执行有效的转换，返回 0。</p>
<p><strong>说明：</strong></p>
<p>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2<sup>31</sup>,  2<sup>31 </sup>− 1]。如果数值超过可表示的范围，则返回  INT_MAX (2<sup>31 </sup>− 1) 或 INT_MIN (−2<sup>31</sup>) 。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> ""42""
<strong>输出:</strong> 42
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> ""   -42""
<strong>输出:</strong> -42
<strong>解释: </strong>第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> ""4193 with words""
<strong>输出:</strong> 4193
<strong>解释:</strong> 转换截止于数字 '3' ，因为它的下一个字符不为数字。
</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong> ""words and 987""
<strong>输出:</strong> 0
<strong>解释:</strong> 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。</pre>
<p><strong>示例 5:</strong></p>
<pre><strong>输入:</strong> ""-91283472332""
<strong>输出:</strong> -2147483648
<strong>解释:</strong> 数字 ""-91283472332"" 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−2<sup>31</sup>) 。
</pre>
</div></div>"
9,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 121
<strong>输出:</strong> true
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> -121
<strong>输出:</strong> false
<strong>解释:</strong> 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> 10
<strong>输出:</strong> false
<strong>解释:</strong> 从右向左读, 为 01 。因此它不是一个回文数。
</pre>
<p><strong>进阶:</strong></p>
<p>你能不将整数转为字符串来解决这个问题吗？</p>
</div></div>"
10,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>)。实现支持 <code>'.'</code> 和 <code>'*'</code> 的正则表达式匹配。</p>
<pre>'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
</pre>
<p>匹配应该覆盖<strong>整个</strong>字符串 (<code>s</code>) ，而不是部分字符串。</p>
<p><strong>说明:</strong></p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong>
s = ""aa""
p = ""a""
<strong>输出:</strong> false
<strong>解释:</strong> ""a"" 无法匹配 ""aa"" 整个字符串。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong>
s = ""aa""
p = ""a*""
<strong>输出:</strong> true
<strong>解释:</strong> '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 ""aa""。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong>
s = ""ab""
p = "".*""
<strong>输出:</strong> true
<strong>解释:</strong> "".*"" 表示可匹配零个或多个('*')任意字符('.')。
</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong>
s = ""aab""
p = ""c*a*b""
<strong>输出:</strong> true
<strong>解释:</strong> 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 ""aab""。
</pre>
<p><strong>示例 5:</strong></p>
<pre><strong>输入:</strong>
s = ""mississippi""
p = ""mis*is*p*.""
<strong>输出:</strong> false</pre>
</div></div>"
11,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定 <em>n</em> 个非负整数 <em>a</em><sub>1</sub>，<em>a</em><sub>2，</sub>...，<em>a</em><sub>n，</sub>每个数代表坐标中的一个点 (<em>i</em>, <em>a<sub>i</sub></em>) 。画 <em>n</em> 条垂直线，使得垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>a<sub>i</sub></em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p>
<p><strong>注意：</strong>你不能倾斜容器，<em>n</em> 至少是2。</p>
</div></div>"
12,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<pre><strong>字符</strong>          <strong>数值</strong>
I             1
V             5
X             10
L             50
C             100
D             500
M             1000</pre>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 3
<strong>输出:</strong> ""III""</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 4
<strong>输出:</strong> ""IV""</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> 9
<strong>输出:</strong> ""IX""</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong> 58
<strong>输出:</strong> ""LVIII""
<strong>解释:</strong> C = 100, L = 50, XXX = 30, III = 3.
</pre>
<p><strong>示例 5:</strong></p>
<pre><strong>输入:</strong> 1994
<strong>输出:</strong> ""MCMXCIV""
<strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</pre>
</div></div>"
13,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>罗马数字包含以下七种字符：<code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<pre><strong>字符</strong>          <strong>数值</strong>
I             1
V             5
X             10
L             50
C             100
D             500
M             1000</pre>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> ""III""
<strong>输出:</strong> 3</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> ""IV""
<strong>输出:</strong> 4</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> ""IX""
<strong>输出:</strong> 9</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong> ""LVIII""
<strong>输出:</strong> 58
<strong>解释:</strong> C = 100, L = 50, XXX = 30, III = 3.
</pre>
<p><strong>示例 5:</strong></p>
<pre><strong>输入:</strong> ""MCMXCIV""
<strong>输出:</strong> 1994
<strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</pre>
</div></div>"
14,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>""""</code>。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入: </strong>[""flower"",""flow"",""flight""]
<strong>输出:</strong> ""fl""
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入: </strong>[""dog"",""racecar"",""car""]
<strong>输出:</strong> """"
<strong>解释:</strong> 输入不存在公共前缀。
</pre>
<p><strong>说明:</strong></p>
<p>所有输入只包含小写字母 <code>a-z</code> 。</p>
</div></div>"
15,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c = </em>0 ？找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<pre>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</pre>
</div></div>"
16,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code><em> </em>和 一个目标值 <code>target</code>。找出 <code>nums</code><em> </em>中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<pre>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
</pre>
</div></div>"
17,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src=""http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png""/></p>
<p><strong>示例:</strong></p>
<pre><strong>输入：</strong>""23""
<strong>输出：</strong>[""ad"", ""ae"", ""af"", ""bd"", ""be"", ""bf"", ""cd"", ""ce"", ""cf""].
</pre>
<p><strong>说明:</strong><br/>
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
</div></div>"
18,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 <em>a，</em><em>b，c</em> 和 <em>d</em> ，使得 <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p>
<p><strong>注意：</strong></p>
<p>答案中不可以包含重复的四元组。</p>
<p><strong>示例：</strong></p>
<pre>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
</pre>
</div></div>"
19,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个链表，删除链表的倒数第 <em>n </em>个节点，并且返回链表的头结点。</p>
<p><strong>示例：</strong></p>
<pre>给定一个链表: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, 和 <strong><em>n</em> = 2</strong>.

当删除了倒数第二个节点后，链表变为 <strong>1-&gt;2-&gt;3-&gt;5</strong>.
</pre>
<p><strong>说明：</strong></p>
<p>给定的 <em>n</em> 保证是有效的。</p>
<p><strong>进阶：</strong></p>
<p>你能尝试使用一趟扫描实现吗？</p>
</div></div>"
20,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> ""()""
<strong>输出:</strong> true
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> ""()[]{}""
<strong>输出:</strong> true
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> ""(]""
<strong>输出:</strong> false
</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong> ""([)]""
<strong>输出:</strong> false
</pre>
<p><strong>示例 5:</strong></p>
<pre><strong>输入:</strong> ""{[]}""
<strong>输出:</strong> true</pre>
</div></div>"
21,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>1-&gt;2-&gt;4, 1-&gt;3-&gt;4
<strong>输出：</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
</pre>
</div></div>"
22,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给出 <em>n</em> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。</p>
<p>例如，给出 <em>n </em>=<em> </em>3，生成结果为：</p>
<pre>[
  ""((()))"",
  ""(()())"",
  ""(())()"",
  ""()(())"",
  ""()()()""
]
</pre>
</div></div>"
23,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>合并 <em>k </em>个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong>
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
<strong>输出:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</pre>
</div></div>"
24,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p><strong>示例:</strong></p>
<pre>给定 <code>1-&gt;2-&gt;3-&gt;4</code>, 你应该返回 <code>2-&gt;1-&gt;4-&gt;3</code>.</pre>
<p><strong>说明:</strong></p>
<ul>
<li>你的算法只能使用常数的额外空间。</li>
<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</li>
</ul>
</div></div>"
25,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给出一个链表，每 <em>k </em>个节点一组进行翻转，并返回翻转后的链表。</p>
<p><em>k </em>是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <em>k </em>的整数倍，那么将最后剩余节点保持原有顺序。</p>
<p><strong>示例 :</strong></p>
<p>给定这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>当 <em>k </em>= 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>当 <em>k </em>= 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p><strong>说明 :</strong></p>
<ul>
<li>你的算法只能使用常数的额外空间。</li>
<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</li>
</ul>
</div></div>"
26,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个排序数组，你需要在<strong><a href=""http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a></strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong><a href=""https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a>修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<pre>给定数组 <em>nums</em> = <strong>[1,1,2]</strong>, 

函数应该返回新的长度 <strong>2</strong>, 并且原数组 <em>nums </em>的前两个元素被修改为 <strong><code>1</code></strong>, <strong><code>2</code></strong>。 

你不需要考虑数组中超出新长度后面的元素。</pre>
<p><strong>示例 2:</strong></p>
<pre>给定<em> nums </em>= <strong>[0,0,1,1,1,2,2,3,3,4]</strong>,

函数应该返回新的长度 <strong>5</strong>, 并且原数组 <em>nums </em>的前五个元素被修改为 <strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>2</code></strong>, <strong><code>3</code></strong>, <strong><code>4</code></strong>。

你不需要考虑数组中超出新长度后面的元素。
</pre>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre>// <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中<strong>该长度范围内</strong>的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</pre>
</div></div>"
27,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个数组 <em>nums </em>和一个值 <em>val</em>，你需要<strong><a href=""https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a></strong>移除所有数值等于 <em>val </em>的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong><a href=""https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a>修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 1:</strong></p>
<pre>给定 <em>nums</em> = <strong>[3,2,2,3]</strong>, <em>val</em> = <strong>3</strong>,

函数应该返回新的长度 <strong>2</strong>, 并且 <em>nums </em>中的前两个元素均为 <strong>2</strong>。

你不需要考虑数组中超出新长度后面的元素。
</pre>
<p><strong>示例 2:</strong></p>
<pre>给定 <em>nums</em> = <strong>[0,1,2,2,3,0,4,2]</strong>, <em>val</em> = <strong>2</strong>,

函数应该返回新的长度 <strong><code>5</code></strong>, 并且 <em>nums </em>中的前五个元素为 <strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>3</code></strong>, <strong><code>0</code></strong>, <strong>4</strong>。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。
</pre>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre>// <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中<strong>该长度范围内</strong>的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</pre>
</div></div>"
28,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>实现 <a href=""https://baike.baidu.com/item/strstr/811469"" target=""_blank"">strStr()</a> 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  <strong>-1</strong>。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> haystack = ""hello"", needle = ""ll""
<strong>输出:</strong> 2
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> haystack = ""aaaaa"", needle = ""bba""
<strong>输出:</strong> -1
</pre>
<p><strong>说明:</strong></p>
<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 <a href=""https://baike.baidu.com/item/strstr/811469"" target=""_blank"">strstr()</a> 以及 Java的 <a href=""https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)"" target=""_blank"">indexOf()</a> 定义相符。</p>
</div></div>"
29,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的商。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> dividend = 10, divisor = 3
<strong>输出:</strong> 3</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> dividend = 7, divisor = -3
<strong>输出:</strong> -2</pre>
<p><strong>说明:</strong></p>
<ul>
<li>被除数和除数均为 32 位有符号整数。</li>
<li>除数不为 0。</li>
<li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2<sup>31</sup>,  2<sup>31 </sup>− 1]。本题中，如果除法结果溢出，则返回 2<sup>31 </sup>− 1。</li>
</ul>
</div></div>"
30,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串 <strong>s </strong>和一些长度相同的单词 <strong>words。</strong>在<strong> s </strong>中找出可以恰好串联 <strong>words </strong>中所有单词的子串的起始位置。</p>
<p>注意子串要与 <strong>words </strong>中的单词完全匹配，中间不能有其他字符，但不需要考虑 <strong>words </strong>中单词串联的顺序。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:
  s =</strong> ""barfoothefoobarman"",
<strong>  words = </strong>[""foo"",""bar""]
<strong>输出:</strong> <code>[0,9]</code>
<strong>解释:</strong> 从索引 0 和 9 开始的子串分别是 ""barfoor"" 和 ""foobar"" 。
输出的顺序不重要, [9,0] 也是有效答案。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:
  s =</strong> ""wordgoodstudentgoodword"",
<strong>  words = </strong>[""word"",""student""]
<strong>输出:</strong> <code>[]</code>
</pre>
</div></div>"
31,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须<strong><a href=""https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a></strong>修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br/>
<code>1,2,3</code> → <code>1,3,2</code><br/>
<code>3,2,1</code> → <code>1,2,3</code><br/>
<code>1,1,5</code> → <code>1,5,1</code></p>
</div></div>"
32,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> ""(()""
<strong>输出:</strong> 2
<strong>解释:</strong> 最长有效括号子串为 <code>""()""</code>
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> ""<code>)()())</code>""
<strong>输出:</strong> 4
<strong>解释:</strong> 最长有效括号子串为 <code>""()()""</code>
</pre>
</div></div>"
33,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> nums = [<code>4,5,6,7,0,1,2]</code>, target = 0
<strong>输出:</strong> 4
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> nums = [<code>4,5,6,7,0,1,2]</code>, target = 3
<strong>输出:</strong> -1</pre>
</div></div>"
34,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p>
<p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> nums = [<code>5,7,7,8,8,10]</code>, target = 8
<strong>输出:</strong> [3,4]</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> nums = [<code>5,7,7,8,8,10]</code>, target = 6
<strong>输出:</strong> [-1,-1]</pre>
</div></div>"
35,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [1,3,5,6], 5
<strong>输出:</strong> 2
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [1,3,5,6], 2
<strong>输出:</strong> 1
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> [1,3,5,6], 7
<strong>输出:</strong> 4
</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong> [1,3,5,6], 0
<strong>输出:</strong> 0
</pre>
</div></div>"
36,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>判断一个 9x9 的数独是否有效。只需要<strong>根据以下规则</strong>，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li>
</ol>
<p><img src=""https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"" style=""height: 250px; width: 250px;""/></p>
<p><small>上图是一个部分填充的有效的数独。</small></p>
<p>数独部分空格内已填入了数字，空白格用 <code>'.'</code> 表示。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong>
[
  [""5"",""3"",""."",""."",""7"",""."",""."",""."","".""],
  [""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""],
  [""."",""9"",""8"",""."",""."",""."",""."",""6"","".""],
  [""8"",""."",""."",""."",""6"",""."",""."",""."",""3""],
  [""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""],
  [""7"",""."",""."",""."",""2"",""."",""."",""."",""6""],
  [""."",""6"",""."",""."",""."",""."",""2"",""8"","".""],
  [""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""],
  [""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]
]
<strong>输出:</strong> true
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong>
[
  [""8"",""3"",""."",""."",""7"",""."",""."",""."","".""],
  [""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""],
  [""."",""9"",""8"",""."",""."",""."",""."",""6"","".""],
  [""8"",""."",""."",""."",""6"",""."",""."",""."",""3""],
  [""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""],
  [""7"",""."",""."",""."",""2"",""."",""."",""."",""6""],
  [""."",""6"",""."",""."",""."",""."",""2"",""8"","".""],
  [""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""],
  [""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]
]
<strong>输出:</strong> false
<strong>解释:</strong> 除了第一行的第一个数字从<strong> 5</strong> 改为 <strong>8 </strong>以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</pre>
<p><strong>说明:</strong></p>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>给定数独序列只包含数字 <code>1-9</code> 和字符 <code>'.'</code> 。</li>
<li>给定数独永远是 <code>9x9</code> 形式的。</li>
</ul>
</div></div>"
37,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>编写一个程序，通过已填充的空格来解决数独问题。</p>
<p>一个数独的解法需<strong>遵循如下规则</strong>：</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li>
</ol>
<p>空白格用 <code>'.'</code> 表示。</p>
<p><img src=""http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png""/></p>
<p><small>一个数独。</small></p>
<p><img src=""http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png""/></p>
<p><small>答案被标成红色。</small></p>
<p><strong>Note:</strong></p>
<ul>
<li>给定的数独序列只包含数字 <code>1-9</code> 和字符 <code>'.'</code> 。</li>
<li>你可以假设给定的数独只有唯一解。</li>
<li>给定数独永远是 <code>9x9</code> 形式的。</li>
</ul>
</div></div>"
38,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>报数序列是指一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p>
<pre>1.     1
2.     11
3.     21
4.     1211
5.     111221
</pre>
<p><code>1</code> 被读作  <code>""one 1""</code>  (<code>""一个一""</code>) , 即 <code>11</code>。<br/>
<code>11</code> 被读作 <code>""two 1s""</code> (<code>""两个一""</code>）, 即 <code>21</code>。<br/>
<code>21</code> 被读作 <code>""one 2""</code>,  ""<code>one 1""</code> （<code>""一个二""</code> ,  <code>""一个一""</code>) , 即 <code>1211</code>。</p>
<p>给定一个正整数 <em>n</em> ，输出报数序列的第 <em>n</em> 项。</p>
<p>注意：整数顺序将表示为一个字符串。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 1
<strong>输出:</strong> ""1""
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 4
<strong>输出:</strong> ""1211""
</pre>
</div></div>"
39,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的数字可以无限制重复被选取。</p>
<p><strong>说明：</strong></p>
<ul>
<li>所有数字（包括 <code>target</code>）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> candidates = <code>[2,3,6,7], </code>target = <code>7</code>,
<strong>所求解集为:</strong>
[
  [7],
  [2,2,3]
]
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> candidates = [2,3,5]<code>, </code>target = 8,
<strong>所求解集为:</strong>
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]</pre>
</div></div>"
40,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>
<p><strong>说明：</strong></p>
<ul>
<li>所有数字（包括目标数）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> candidates = <code>[10,1,2,7,6,1,5]</code>, target = <code>8</code>,
<strong>所求解集为:</strong>
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> candidates = [2,5,2,1,2], target = 5,
<strong>所求解集为:</strong>
[
  [1,2,2],
  [5]
]</pre>
</div></div>"
41,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p>
<p><strong>示例 1:</strong></p>
<pre>输入: [1,2,0]
输出: 3
</pre>
<p><strong>示例 2:</strong></p>
<pre>输入: [3,4,-1,1]
输出: 2
</pre>
<p><strong>示例 3:</strong></p>
<pre>输入: [7,8,9,11,12]
输出: 1
</pre>
<p><strong>说明:</strong></p>
<p>你的算法的时间复杂度应为O(<em>n</em>)，并且只能使用常数级别的空间。</p>
</div></div>"
42,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src=""/static/images/problemset/rainwatertrap.png""/></p>
<p><small>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 <strong>感谢 Marcos</strong> 贡献此图。</small></p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> [0,1,0,2,1,0,1,3,2,1,2,1]
<strong>输出:</strong> 6</pre>
</div></div>"
43,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> num1 = ""2"", num2 = ""3""
<strong>输出:</strong> ""6""</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> num1 = ""123"", num2 = ""456""
<strong>输出:</strong> ""56088""</pre>
<p><strong>说明：</strong></p>
<ol>
<li><code>num1</code> 和 <code>num2</code> 的长度小于110。</li>
<li><code>num1</code> 和 <code>num2</code> 只包含数字 <code>0-9</code>。</li>
<li><code>num1</code> 和 <code>num2</code> 均不以零开头，除非是数字 0 本身。</li>
<li><strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li>
</ol>
</div></div>"
44,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>'?'</code> 和 <code>'*'</code> 的通配符匹配。</p>
<pre>'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
</pre>
<p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p>
<p><strong>说明:</strong></p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong>
s = ""aa""
p = ""a""
<strong>输出:</strong> false
<strong>解释:</strong> ""a"" 无法匹配 ""aa"" 整个字符串。</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong>
s = ""aa""
p = ""*""
<strong>输出:</strong> true
<strong>解释:</strong> '*' 可以匹配任意字符串。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong>
s = ""cb""
p = ""?a""
<strong>输出:</strong> false
<strong>解释:</strong> '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong>
s = ""adceb""
p = ""*a*b""
<strong>输出:</strong> true
<strong>解释:</strong> 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 ""dce"".
</pre>
<p><strong>示例 5:</strong></p>
<pre><strong>输入:</strong>
s = ""acdcb""
p = ""a*c?b""
<strong>输入:</strong> false</pre>
</div></div>"
45,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> [2,3,1,1,4]
<strong>输出:</strong> 2
<strong>解释:</strong> 跳到最后一个位置的最小跳跃数是 <code>2</code>。
     从下标为 0 跳到下标为 1 的位置，跳 <code>1</code> 步，然后跳 <code>3</code> 步到达数组的最后一个位置。
</pre>
<p><strong>说明:</strong></p>
<p>假设你总是可以到达数组的最后一个位置。</p>
</div></div>"
46,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> [1,2,3]
<strong>输出:</strong>
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]</pre>
</div></div>"
47,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> [1,1,2]
<strong>输出:</strong>
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]</pre>
</div></div>"
48,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个 <em>n </em>× <em>n</em> 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p><strong>说明：</strong></p>
<p>你必须在<strong><a href=""https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a></strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p>
<p><strong>示例 1:</strong></p>
<pre>给定 <strong>matrix</strong> = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

<strong>原地</strong>旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
</pre>
<p><strong>示例 2:</strong></p>
<pre>给定 <strong>matrix</strong> =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

<strong>原地</strong>旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
</pre>
</div></div>"
49,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> <code>[""eat"", ""tea"", ""tan"", ""ate"", ""nat"", ""bat""]</code>,
<strong>输出:</strong>
[
  [""ate"",""eat"",""tea""],
  [""nat"",""tan""],
  [""bat""]
]</pre>
<p><strong>说明：</strong></p>
<ul>
<li>所有输入均为小写字母。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
</div></div>"
50,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>实现 <a href=""https://www.cplusplus.com/reference/valarray/pow/"" target=""_blank"">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 2.00000, 10
<strong>输出:</strong> 1024.00000
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 2.10000, 3
<strong>输出:</strong> 9.26100
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> 2.00000, -2
<strong>输出:</strong> 0.25000
<strong>解释:</strong> 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25</pre>
<p><strong>说明:</strong></p>
<ul>
<li>-100.0 &lt; <em>x</em> &lt; 100.0</li>
<li><em>n</em> 是 32 位有符号整数，其数值范围是 [−2<sup>31</sup>, 2<sup>31 </sup>− 1] 。</li>
</ul>
</div></div>"
51,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p><em>n </em>皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src=""/static/images/problemset/8-queens.png""/></p>
<p><small>上图为 8 皇后问题的一种解法。</small></p>
<p>给定一个整数 <em>n</em>，返回所有不同的 <em>n </em>皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 <em>n</em> 皇后问题的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> 4
<strong>输出:</strong> [
 ["".Q.."",  // 解法 1
  ""...Q"",
  ""Q..."",
  ""..Q.""],

 [""..Q."",  // 解法 2
  ""Q..."",
  ""...Q"",
  "".Q..""]
]
<strong>解释:</strong> 4 皇后问题存在两个不同的解法。
</pre>
</div></div>"
52,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p><em>n </em>皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src=""/static/images/problemset/8-queens.png""/></p>
<p><small>上图为 8 皇后问题的一种解法。</small></p>
<p>给定一个整数 <em>n</em>，返回 <em>n</em> 皇后不同的解决方案的数量。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> 4
<strong>输出:</strong> 2
<strong>解释:</strong> 4 皇后问题存在如下两个不同的解法。
[
 ["".Q.."",  // 解法 1
  ""...Q"",
  ""Q..."",
  ""..Q.""],

 [""..Q."",  // 解法 2
  ""Q..."",
  ""...Q"",
  "".Q..""]
]
</pre>
</div></div>"
53,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> [-2,1,-3,4,-1,2,1,-5,4],
<strong>输出:</strong> 6
<strong>解释:</strong> 连续子数组 [4,-1,2,1] 的和最大，为 6。
</pre>
<p><strong>进阶:</strong></p>
<p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p>
</div></div>"
54,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个包含 <em>m</em> x <em>n</em> 个元素的矩阵（<em>m</em> 行, <em>n</em> 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong>
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
<strong>输出:</strong> [1,2,3,6,9,8,7,4,5]
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong>
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
<strong>输出:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]
</pre>
</div></div>"
55,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [2,3,1,1,4]
<strong>输出:</strong> true
<strong>解释:</strong> 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [3,2,1,0,4]
<strong>输出:</strong> false
<strong>解释:</strong> 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
</pre>
</div></div>"
56,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [[1,3],[2,6],[8,10],[15,18]]
<strong>输出:</strong> [[1,6],[8,10],[15,18]]
<strong>解释:</strong> 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [[1,4],[4,5]]
<strong>输出:</strong> [[1,5]]
<strong>解释:</strong> 区间 [1,4] 和 [4,5] 可被视为重叠区间。</pre>
</div></div>"
57,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]
<strong>输出:</strong> [[1,5],[6,9]]
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> intervals = <code>[[1,2],[3,5],[6,7],[8,10],[12,16]]</code>, newInterval = <code>[4,8]</code>
<strong>输出:</strong> [[1,2],[3,10],[12,16]]
<strong>解释:</strong> 这是因为新的区间 <code>[4,8]</code> 与 <code>[3,5],[6,7],[8,10]</code> 重叠。
</pre>
</div></div>"
58,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个仅包含大小写字母和空格 <code>' '</code> 的字符串，返回其最后一个单词的长度。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<p><strong>说明：</strong>一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> ""Hello World""
<strong>输出:</strong> 5
</pre>
</div></div>"
59,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个正整数 <em>n</em>，生成一个包含 1 到 <em>n</em><sup>2</sup> 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> 3
<strong>输出:</strong>
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]</pre>
</div></div>"
60,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给出集合 <code>[1,2,3,…,<em>n</em>]</code>，其所有元素共有 <em>n</em>! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 <em>n </em>= 3 时, 所有排列如下：</p>
<ol>
<li><code>""123""</code></li>
<li><code>""132""</code></li>
<li><code>""213""</code></li>
<li><code>""231""</code></li>
<li><code>""312""</code></li>
<li><code>""321""</code></li>
</ol>
<p>给定 <em>n</em> 和 <em>k</em>，返回第 <em>k</em> 个排列。</p>
<p><strong>说明：</strong></p>
<ul>
<li>给定<em> n</em> 的范围是 [1, 9]。</li>
<li>给定 <em>k </em>的范围是[1,  <em>n</em>!]。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> n = 3, k = 3
<strong>输出:</strong> ""213""
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> n = 4, k = 9
<strong>输出:</strong> ""2314""
</pre>
</div></div>"
61,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k </em>个位置，其中 <em>k </em>是非负数。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2
<strong>输出:</strong> 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
<strong>解释:</strong>
向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL
向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 0-&gt;1-&gt;2-&gt;NULL, k = 4
<strong>输出:</strong> <code>2-&gt;0-&gt;1-&gt;NULL</code>
<strong>解释:</strong>
向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL
向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL
向右旋转 3 步: <code>0-&gt;1-&gt;2-&gt;NULL</code>
向右旋转 4 步: <code>2-&gt;0-&gt;1-&gt;NULL</code></pre>
</div></div>"
62,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>一个机器人位于一个 <em>m x n </em>网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src=""/static/images/problemset/robot_maze.png""/></p>
<p><small>例如，上图是一个7 x 3 的网格。有多少可能的路径？</small></p>
<p><strong>说明：</strong><em>m</em> 和 <em>n </em>的值均不超过 100。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> m = 3, n = 2
<strong>输出:</strong> 3
<strong>解释:</strong>
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -&gt; 向右 -&gt; 向下
2. 向右 -&gt; 向下 -&gt; 向右
3. 向下 -&gt; 向右 -&gt; 向右
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> m = 7, n = 3
<strong>输出:</strong> 28</pre>
</div></div>"
63,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>一个机器人位于一个 <em>m x n </em>网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src=""/static/images/problemset/robot_maze.png""/></p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><strong>说明：</strong><em>m</em> 和 <em>n </em>的值均不超过 100。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:
</strong>[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
<strong>输出:</strong> 2
<strong>解释:</strong>
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 <code>2</code> 条不同的路径：
1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右
</pre>
</div></div>"
64,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong>
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
<strong>输出:</strong> 7
<strong>解释:</strong> 因为路径 1→3→1→1→1 的总和最小。
</pre>
</div></div>"
65,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>验证给定的字符串是否为数字。</p>
<p>例如:<br/>
<code>""0""</code> =&gt; <code>true</code><br/>
<code>"" 0.1 ""</code> =&gt; <code>true</code><br/>
<code>""abc""</code> =&gt; <code>false</code><br/>
<code>""1 a""</code> =&gt; <code>false</code><br/>
<code>""2e10""</code> =&gt; <code>true</code></p>
<p><strong>说明:</strong> 我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。</p>
<p><strong>更新于 2015-02-10:</strong><br/>
<code>C++</code>函数的形式已经更新了。如果你仍然看见你的函数接收 <code>const char *</code> 类型的参数，请点击重载按钮重置你的代码。</p>
</div></div>"
66,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个<strong>非负整数</strong>组成的<strong>非空</strong>数组，在该数的基础上加一，返回一个新的数组。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [1,2,3]
<strong>输出:</strong> [1,2,4]
<strong>解释:</strong> 输入数组表示数字 123。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [4,3,2,1]
<strong>输出:</strong> [4,3,2,2]
<strong>解释:</strong> 输入数组表示数字 4321。
</pre>
</div></div>"
67,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为<strong>非空</strong>字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> a = ""11"", b = ""1""
<strong>输出:</strong> ""100""</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> a = ""1010"", b = ""1011""
<strong>输出:</strong> ""10101""</pre>
</div></div>"
68,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个单词数组和一个长度 <em>maxWidth</em>，重新排版单词，使其成为每行恰好有 <em>maxWidth</em> 个字符，且左右两端对齐的文本。</p>
<p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 <code>' '</code> 填充，使得每行恰好有 <em>maxWidth</em> 个字符。</p>
<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>
<p>文本的最后一行应为左对齐，且单词之间不插入<strong>额外的</strong>空格。</p>
<p><strong>说明:</strong></p>
<ul>
<li>单词是指由非空格字符组成的字符序列。</li>
<li>每个单词的长度大于 0，小于等于 <em>maxWidth</em>。</li>
<li>输入单词数组 <code>words</code> 至少包含一个单词。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong>
words = [""This"", ""is"", ""an"", ""example"", ""of"", ""text"", ""justification.""]
maxWidth = 16
<strong>输出:</strong>
[
   ""This    is    an"",
   ""example  of text"",
   ""justification.  ""
]
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong>
words = [""What"",""must"",""be"",""acknowledgment"",""shall"",""be""]
maxWidth = 16
<strong>输出:</strong>
[
  ""What   must   be"",
  ""acknowledgment  "",
  ""shall be        ""
]
<strong>解释: </strong>注意最后一行的格式应为 ""shall be    "" 而不是 ""shall     be"",
     因为最后一行应为左对齐，而不是左右两端对齐。       
     第二行同样为左对齐，这是因为这行只包含一个单词。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong>
words = [""Science"",""is"",""what"",""we"",""understand"",""well"",""enough"",""to"",""explain"",
         ""to"",""a"",""computer."",""Art"",""is"",""everything"",""else"",""we"",""do""]
maxWidth = 20
<strong>输出:</strong>
[
  ""Science  is  what we"",
  ""understand      well"",
  ""enough to explain to"",
  ""a  computer.  Art is"",
  ""everything  else  we"",
  ""do                  ""
]
</pre>
</div></div>"
69,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>实现 <code>int sqrt(int x)</code> 函数。</p>
<p>计算并返回 <em>x</em> 的平方根，其中 <em>x </em>是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 4
<strong>输出:</strong> 2
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 8
<strong>输出:</strong> 2
<strong>说明:</strong> 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
</pre>
</div></div>"
70,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>假设你正在爬楼梯。需要 <em>n</em> 步你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong> 2
<strong>输出：</strong> 2
<strong>解释：</strong> 有两种方法可以爬到楼顶。
1.  1 步 + 1 步
2.  2 步</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong> 3
<strong>输出：</strong> 3
<strong>解释：</strong> 有三种方法可以爬到楼顶。
1.  1 步 + 1 步 + 1 步
2.  1 步 + 2 步
3.  2 步 + 1 步
</pre>
</div></div>"
71,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个文档 (Unix-style) 的完全路径，请进行路径简化。</p>
<p>例如，<br/>
<strong>path</strong> = <code>""/home/""</code>, =&gt; <code>""/home""</code><br/>
<strong>path</strong> = <code>""/a/./b/../../c/""</code>, =&gt; <code>""/c""</code></p>
<p><strong>边界情况:</strong></p>
<ul>
<li>你是否考虑了 路径 = <code>""/../""</code> 的情况？<br/>
	在这种情况下，你需返回 <code>""/""</code> 。</li>
<li>此外，路径中也可能包含多个斜杠 <code>'/'</code> ，如 <code>""/home//foo/""</code> 。<br/>
	在这种情况下，你可忽略多余的斜杠，返回 <code>""/home/foo""</code> 。</li>
</ul>
</div></div>"
72,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定两个单词 <em>word1</em> 和 <em>word2</em>，计算出将 <em>word1</em> 转换成 <em>word2 </em>所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ol>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ol>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> word1 = ""horse"", word2 = ""ros""
<strong>输出:</strong> 3
<strong>解释:</strong> 
horse -&gt; rorse (将 'h' 替换为 'r')
rorse -&gt; rose (删除 'r')
rose -&gt; ros (删除 'e')
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> word1 = ""intention"", word2 = ""execution""
<strong>输出:</strong> 5
<strong>解释:</strong> 
intention -&gt; inention (删除 't')
inention -&gt; enention (将 'i' 替换为 'e')
enention -&gt; exention (将 'n' 替换为 'x')
exention -&gt; exection (将 'n' 替换为 'c')
exection -&gt; execution (插入 'u')
</pre>
</div></div>"
73,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个 <em>m</em> x <em>n</em> 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用<strong><a href=""http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a></strong>算法<strong>。</strong></p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
<strong>输出:</strong> 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
<strong>输出:</strong> 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]</pre>
<p><strong>进阶:</strong></p>
<ul>
<li>一个直接的解决方案是使用  O(<em>m</em><em>n</em>) 的额外空间，但这并不是一个好的解决方案。</li>
<li>一个简单的改进方案是使用 O(<em>m</em> + <em>n</em>) 的额外空间，但这仍然不是最好的解决方案。</li>
<li>你能想出一个常数空间的解决方案吗？</li>
</ul>
</div></div>"
74,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>编写一个高效的算法来判断 <em>m</em> x <em>n</em> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong>
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
<strong>输出:</strong> true
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong>
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 13
<strong>输出:</strong> false</pre>
</div></div>"
75,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个包含红色、白色和蓝色，一共 <em>n </em>个元素的数组，<strong><a href=""https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a></strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p><strong>注意:</strong><br/>
不能使用代码库中的排序函数来解决这道题。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> [2,0,2,1,1,0]
<strong>输出:</strong> [0,0,1,1,2,2]</pre>
<p><strong>进阶：</strong></p>
<ul>
<li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br/>
	首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li>
<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>
</div></div>"
76,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串 S 和一个字符串 T，请在 S 中找出包含 T 所有字母的最小子串。</p>
<p><strong>示例：</strong></p>
<pre><strong>输入: S</strong> = ""ADOBECODEBANC"", <strong>T</strong> = ""ABC""
<strong>输出:</strong> ""BANC""</pre>
<p><strong>说明：</strong></p>
<ul>
<li>如果 S 中不存这样的子串，则返回空字符串 <code>""""</code>。</li>
<li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
</div></div>"
77,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 ... <em>n </em>中所有可能的 <em>k</em> 个数的组合。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> n = 4, k = 2
<strong>输出:</strong>
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]</pre>
</div></div>"
78,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明：</strong>解集不能包含重复的子集。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> nums = [1,2,3]
<strong>输出:</strong>
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]</pre>
</div></div>"
79,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p><strong>示例:</strong></p>
<pre>board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = ""<strong>ABCCED</strong>"", 返回 <strong>true</strong>.
给定 word = ""<strong>SEE</strong>"", 返回 <strong>true</strong>.
给定 word = ""<strong>ABCB</strong>"", 返回 <strong>false</strong>.</pre>
</div></div>"
80,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个排序数组，你需要在<strong><a href=""http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a></strong>删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong><a href=""https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a>修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<pre>给定 <em>nums</em> = <strong>[1,1,1,2,2,3]</strong>,

函数应返回新长度 length = <strong><code>5</code></strong>, 并且原数组的前五个元素被修改为 <strong><code>1, 1, 2, 2,</code></strong> <strong>3 </strong>。

你不需要考虑数组中超出新长度后面的元素。</pre>
<p><strong>示例 2:</strong></p>
<pre>给定 <em>nums</em> = <strong>[0,0,1,1,1,1,2,3,3]</strong>,

函数应返回新长度 length = <strong><code>7</code></strong>, 并且原数组的前五个元素被修改为 <strong><code>0</code></strong>, <strong>0</strong>, <strong>1</strong>, <strong>1</strong>, <strong>2</strong>, <strong>3</strong>, <strong>3 。</strong>

你不需要考虑数组中超出新长度后面的元素。
</pre>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre>// <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中<strong>该长度范围内</strong>的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}</pre>
</div></div>"
81,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,0,1,2,2,5,6]</code> 可能变为 <code>[2,5,6,0,0,1,2]</code> )。</p>
<p>编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> nums = [2<code>,5,6,0,0,1,2]</code>, target = 0
<strong>输出:</strong> true
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> nums = [2<code>,5,6,0,0,1,2]</code>, target = 3
<strong>输出:</strong> false</pre>
<p><strong>进阶:</strong></p>
<ul>
<li>这是 <a href=""https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/"">搜索旋转排序数组</a> 的延伸题目，本题中的 <code>nums</code>  可能包含重复元素。</li>
<li>这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？</li>
</ul>
</div></div>"
82,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 <em>没有重复出现 </em>的数字。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5
<strong>输出:</strong> 1-&gt;2-&gt;5
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 1-&gt;1-&gt;1-&gt;2-&gt;3
<strong>输出:</strong> 2-&gt;3</pre>
</div></div>"
83,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 1-&gt;1-&gt;2
<strong>输出:</strong> 1-&gt;2
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;3
<strong>输出:</strong> 1-&gt;2-&gt;3</pre>
</div></div>"
84,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src=""/static/images/problemset/histogram.png""/></p>
<p><small>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 <code>[2,1,5,6,2,3]</code>。</small></p>
<p><img src=""/static/images/problemset/histogram_area.png""/></p>
<p><small>图中阴影部分为所能勾勒出的最大矩形面积，其面积为 <code>10</code> 个单位。</small></p>
<p> </p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> [2,1,5,6,2,3]
<strong>输出:</strong> 10</pre>
</div></div>"
85,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong>
[
  [""1"",""0"",""1"",""0"",""0""],
  [""1"",""0"",""<strong>1</strong>"",""<strong>1</strong>"",""<strong>1</strong>""],
  [""1"",""1"",""<strong>1</strong>"",""<strong>1</strong>"",""<strong>1</strong>""],
  [""1"",""0"",""0"",""1"",""0""]
]
<strong>输出:</strong> 6</pre>
</div></div>"
86,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个链表和一个特定值<em> x</em>，对链表进行分隔，使得所有小于 <em>x</em> 的节点都在大于或等于 <em>x</em> 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, <em>x</em> = 3
<strong>输出:</strong> 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5
</pre>
</div></div>"
87,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串 <em>s1</em>，我们可以把它递归地分割成两个非空子字符串，从而将其表示为二叉树。</p>
<p>下图是字符串 <em>s1</em> = <code>""great""</code> 的一种可能的表示形式。</p>
<pre>    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
</pre>
<p>在扰乱这个字符串的过程中，我们可以挑选任何一个非叶节点，然后交换它的两个子节点。</p>
<p>例如，如果我们挑选非叶节点 <code>""gr""</code> ，交换它的两个子节点，将会产生扰乱字符串 <code>""rgeat""</code> 。</p>
<pre>    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
</pre>
<p>我们将 <code>""rgeat”</code> 称作 <code>""great""</code> 的一个扰乱字符串。</p>
<p>同样地，如果我们继续将其节点 <code>""eat""</code> 和 <code>""at""</code> 进行交换，将会产生另一个新的扰乱字符串 <code>""rgtae""</code> 。</p>
<pre>    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
</pre>
<p>我们将 <code>""rgtae”</code> 称作 <code>""great""</code> 的一个扰乱字符串。</p>
<p>给出两个长度相等的字符串 <em>s1 </em>和 <em>s2</em>，判断 <em>s2 </em>是否是 <em>s1 </em>的扰乱字符串。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> s1 = ""great"", s2 = ""rgeat""
<strong>输出:</strong> true
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> s1 = ""abcde"", s2 = ""caebd""
<strong>输出:</strong> false</pre>
</div></div>"
88,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定两个有序整数数组 <em>nums1 </em>和 <em>nums2</em>，将 <em>nums2 </em>合并到 <em>nums1 </em>中<em>，</em>使得 <em>num1 </em>成为一个有序数组。</p>
<p><strong>说明:</strong></p>
<ul>
<li>初始化 <em>nums1</em> 和 <em>nums2</em> 的元素数量分别为 <em>m</em> 和 <em>n</em>。</li>
<li>你可以假设 <em>nums1 </em>有足够的空间（空间大小大于或等于 <em>m + n</em>）来保存 <em>nums2</em> 中的元素。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong>
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

<strong>输出:</strong> [1,2,2,3,5,6]</pre>
</div></div>"
89,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。</p>
<p>给定一个代表编码总位数的非负整数 n，打印格雷码序列。格雷码序列必须以 0 开头。</p>
<p>例如，给定 <em>n</em> = 2，返回 <code>[0,1,3,2]</code>。其格雷编码是：</p>
<pre>00 - 0
01 - 1
11 - 3
10 - 2
</pre>
<p><strong>说明:</strong></p>
<p>对于给定的 <em>n</em>，其格雷编码的顺序并不唯一。</p>
<p>例如 <code>[0,2,3,1]</code> 也是一个有效的格雷编码顺序。</p>
</div></div>"
90,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个可能包含重复元素的整数数组 <em><strong>nums</strong></em>，返回该数组所有可能的子集（幂集）。</p>
<p><strong>说明：</strong>解集不能包含重复的子集。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> [1,2,2]
<strong>输出:</strong>
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]</pre>
</div></div>"
91,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>一条包含字母 <code>A-Z</code> 的消息通过以下方式进行了编码：</p>
<pre>'A' -&gt; 1
'B' -&gt; 2
...
'Z' -&gt; 26
</pre>
<p>给定一个只包含数字的<strong>非空</strong>字符串，请计算解码方法的总数。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> ""12""
<strong>输出:</strong> 2
<strong>解释:</strong> 它可以解码为 ""AB""（1 2）或者 ""L""（12）。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> ""226""
<strong>输出:</strong> 3
<strong>解释:</strong> 它可以解码为 ""BZ"" (2 26), ""VF"" (22 6), 或者 ""BBF"" (2 2 6) 。
</pre>
</div></div>"
92,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p>
<p><strong>说明:</strong><br/>
1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, <em>m</em> = 2, <em>n</em> = 4
<strong>输出:</strong> 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</pre>
</div></div>"
93,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> ""25525511135""
<strong>输出:</strong> <code>[""255.255.11.135"", ""255.255.111.35""]</code></pre>
</div></div>"
94,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二叉树，返回它的<em>中序 </em>遍历。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> [1,null,2,3]
   1
    \
     2
    /
   3

<strong>输出:</strong> [1,3,2]</pre>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
</div></div>"
95,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个整数 <em>n</em>，生成所有由 1 ... <em>n</em> 为节点所组成的<strong>二叉搜索树</strong>。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> 3
<strong>输出:</strong>
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
<strong>解释:</strong>
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</pre>
</div></div>"
96,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个整数 <em>n</em>，求以 1 ... <em>n</em> 为节点组成的二叉搜索树有多少种？</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> 3
<strong>输出:</strong> 5
<strong>解释:
</strong>给定 <em>n</em> = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3</pre>
</div></div>"
97,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定三个字符串 <em>s1</em>, <em>s2</em>, <em>s3</em>, 验证 <em>s3</em> 是否是由 <em>s1</em> 和 <em>s2 </em>交错组成的。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> s1 = ""aabcc"", s2 = ""dbbca"", <em>s3</em> = ""aadbbcbcac""
<strong>输出:</strong> true
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> s1 = ""aabcc"", s2 = ""dbbca"", <em>s3</em> = ""aadbbbaccc""
<strong>输出:</strong> false</pre>
</div></div>"
98,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li>
<li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong>
    2
   / \
  1   3
<strong>输出:</strong> true
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:
</strong>    5
   / \
  1   4
     / \
    3   6
<strong>输出:</strong> false
<strong>解释:</strong> 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
</pre>
</div></div>"
99,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>二叉搜索树中的两个节点被错误地交换。</p>
<p>请在不改变其结构的情况下，恢复这棵树。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [1,3,null,null,2]

   1
  /
 3
  \
   2

<strong>输出:</strong> [3,1,null,null,2]

   3
  /
 1
  \
   2
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [3,1,4,null,null,2]

  3
 / \
1   4
   /
  2

<strong>输出:</strong> [2,1,4,null,null,3]

  2
 / \
1   4
   /
  3</pre>
<p><strong>进阶:</strong></p>
<ul>
<li>使用 O(<em>n</em>) 空间复杂度的解法很容易实现。</li>
<li>你能想出一个只使用常数空间的解决方案吗？</li>
</ul>
</div></div>"
100,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入: </strong>      1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

<strong>输出:</strong> true</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:  </strong>    1          1
          /           \
         2             2

        [1,2],     [1,null,2]

<strong>输出:</strong> false
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong>       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

<strong>输出:</strong> false
</pre>
</div></div>"
101,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<pre>    1
   / \
  2   2
 / \ / \
3  4 4  3
</pre>
<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<pre>    1
   / \
  2   2
   \   \
   3    3
</pre>
<p><strong>说明:</strong></p>
<p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p>
</div></div>"
102,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>例如:<br/>
给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<pre>    3
   / \
  9  20
    /  \
   15   7
</pre>
<p>返回其层次遍历结果：</p>
<pre>[
  [3],
  [9,20],
  [15,7]
]
</pre>
</div></div>"
103,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br/>
给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<pre>    3
   / \
  9  20
    /  \
   15   7
</pre>
<p>返回锯齿形层次遍历如下：</p>
<pre>[
  [3],
  [20,9],
  [15,7]
]
</pre>
</div></div>"
104,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例：</strong><br/>
给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<pre>    3
   / \
  9  20
    /  \
   15   7</pre>
<p>返回它的最大深度 3 。</p>
</div></div>"
105,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<p><strong>注意:</strong><br/>
你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<pre>前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]</pre>
<p>返回如下的二叉树：</p>
<pre>    3
   / \
  9  20
    /  \
   15   7</pre>
</div></div>"
106,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p><strong>注意:</strong><br/>
你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<pre>中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]</pre>
<p>返回如下的二叉树：</p>
<pre>    3
   / \
  9  20
    /  \
   15   7
</pre>
</div></div>"
107,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p>例如：<br/>
给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<pre>    3
   / \
  9  20
    /  \
   15   7
</pre>
<p>返回其自底向上的层次遍历为：</p>
<pre>[
  [15,7],
  [9,20],
  [3]
]
</pre>
</div></div>"
108,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点 </em>的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<pre>给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
</pre>
</div></div>"
109,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点 </em>的左右两个子树的高度差的绝对值不超过 1。</p>
<p><strong>示例:</strong></p>
<pre>给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
</pre>
</div></div>"
110,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点 </em>的左右两个子树的高度差的绝对值不超过1。</p>
</blockquote>
<p><strong>示例 1:</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p>
<pre>    3
   / \
  9  20
    /  \
   15   7</pre>
<p>返回 <code>true</code> 。<br/>
<br/>
<strong>示例 2:</strong></p>
<p>给定二叉树 <code>[1,2,2,3,3,null,null,4,4]</code></p>
<pre>       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
</pre>
<p>返回 <code>false</code> 。</p>
</div></div>"
111,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong></p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<pre>    3
   / \
  9  20
    /  \
   15   7</pre>
<p>返回它的最小深度  2.</p>
</div></div>"
112,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong> <br/>
给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>
<pre>              <strong>5</strong>
             / \
            <strong>4 </strong>  8
           /   / \
          <strong>11 </strong> 13  4
         /  \      \
        7    <strong>2</strong>      1
</pre>
<p>返回 <code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径 <code>5-&gt;4-&gt;11-&gt;2</code>。</p>
</div></div>"
113,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong><br/>
给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>
<pre>              <strong>5</strong>
             / \
            <strong>4</strong>   <strong>8</strong>
           /   / \
          <strong>11</strong>  13  <strong>4</strong>
         /  \    / \
        7    <strong>2</strong>  <strong>5</strong>   1
</pre>
<p>返回:</p>
<pre>[
   [5,4,11,2],
   [5,8,4,5]
]
</pre>
</div></div>"
114,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二叉树，<a href=""https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95/8010757"" target=""_blank"">原地</a>将它展开为链表。</p>
<p>例如，给定二叉树</p>
<pre>    1
   / \
  2   5
 / \   \
3   4   6</pre>
<p>将其展开为：</p>
<pre>1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6</pre>
</div></div>"
115,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串 <strong>S </strong>和一个字符串 <strong>T</strong>，计算在 <strong>S</strong> 的子序列中 <strong>T</strong> 出现的个数。</p>
<p>一个字符串的一个子序列是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>""ACE""</code> 是 <code>""ABCDE""</code> 的一个子序列，而 <code>""AEC""</code> 不是）</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入: </strong>S = <code>""rabbbit""</code>, T = <code>""rabbit""
<strong>输出:</strong> 3
</code><strong>解释:
</strong>
如下图所示, 有 3 种可以从 S 中得到 <code>""rabbit"" 的方案</code>。
(上箭头符号 ^ 表示选取的字母)

<code>rabbbit</code>
^^^^ ^^
<code>rabbbit</code>
^^ ^^^^
<code>rabbbit</code>
^^^ ^^^
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入: </strong>S = <code>""babgbag""</code>, T = <code>""bag""
<strong>输出:</strong> 5
</code><strong>解释:
</strong>
如下图所示, 有 5 种可以从 S 中得到 <code>""bag"" 的方案</code>。 
(上箭头符号 ^ 表示选取的字母)

<code>babgbag</code>
^^ ^
<code>babgbag</code>
^^    ^
<code>babgbag</code>
^    ^^
<code>babgbag</code>
  ^  ^^
<code>babgbag</code>
    ^^^</pre>
</div></div>"
116,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二叉树</p>
<pre>struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}</pre>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
<p><strong>说明:</strong></p>
<ul>
<li>你只能使用额外常数空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
<li>你可以假设它是一个完美二叉树（即所有叶子节点都在同一层，每个父节点都有两个子节点）。</li>
</ul>
<p><strong>示例:</strong></p>
<p>给定完美二叉树，</p>
<pre>     1
   /  \
  2    3
 / \  / \
4  5  6  7</pre>
<p>调用你的函数后，该完美二叉树变为：</p>
<pre>     1 -&gt; NULL
   /  \
  2 -&gt; 3 -&gt; NULL
 / \  / \
4-&gt;5-&gt;6-&gt;7 -&gt; NULL</pre>
</div></div>"
117,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二叉树</p>
<pre>struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
</pre>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
<p><strong>说明:</strong></p>
<ul>
<li>你只能使用额外常数空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<p><strong>示例:</strong></p>
<p>给定二叉树，</p>
<pre>     1
   /  \
  2    3
 / \    \
4   5    7
</pre>
<p>调用你的函数后，该二叉树变为：</p>
<pre>     1 -&gt; NULL
   /  \
  2 -&gt; 3 -&gt; NULL
 / \    \
4-&gt; 5 -&gt; 7 -&gt; NULL</pre>
</div></div>"
118,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个非负整数 <em>numRows，</em>生成杨辉三角的前 <em>numRows </em>行。</p>
<p><img alt="""" src=""https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif""/></p>
<p><small>在杨辉三角中，每个数是它左上方和右上方的数的和。</small></p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> 5
<strong>输出:</strong>
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]</pre>
</div></div>"
119,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k </em>行。</p>
<p><img alt="""" src=""https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif""/></p>
<p><small>在杨辉三角中，每个数是它左上方和右上方的数的和。</small></p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> 3
<strong>输出:</strong> [1,3,3,1]
</pre>
<p><strong>进阶：</strong></p>
<p>你可以优化你的算法到 <em>O</em>(<em>k</em>) 空间复杂度吗？</p>
</div></div>"
120,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>例如，给定三角形：</p>
<pre>[
     [<strong>2</strong>],
    [<strong>3</strong>,4],
   [6,<strong>5</strong>,7],
  [4,<strong>1</strong>,8,3]
]
</pre>
<p>自顶向下的最小路径和为 <code>11</code>（即，<strong>2 </strong>+ <strong>3</strong> + <strong>5 </strong>+ <strong>1</strong> = 11）。</p>
<p><strong>说明：</strong></p>
<p>如果你可以只使用 <em>O</em>(<em>n</em>) 的额外空间（<em>n</em> 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</p>
</div></div>"
121,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [7,1,5,3,6,4]
<strong>输出:</strong> 5
<strong>解释: </strong>在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [7,6,4,3,1]
<strong>输出:</strong> 0
<strong>解释: </strong>在这种情况下, 没有交易完成, 所以最大利润为 0。
</pre>
</div></div>"
122,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [7,1,5,3,6,4]
<strong>输出:</strong> 7
<strong>解释:</strong> 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [1,2,3,4,5]
<strong>输出:</strong> 4
<strong>解释:</strong> 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> [7,6,4,3,1]
<strong>输出:</strong> 0
<strong>解释:</strong> 在这种情况下, 没有交易完成, 所以最大利润为 0。</pre>
</div></div>"
123,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个数组，它的第<em> i</em> 个元素是一支给定的股票在第 <em>i </em>天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <em>两笔 </em>交易。</p>
<p><strong>注意:</strong> 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [3,3,5,0,0,3,1,4]
<strong>输出:</strong> 6
<strong>解释:</strong> 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [1,2,3,4,5]
<strong>输出:</strong> 4
<strong>解释:</strong> 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> [7,6,4,3,1] 
<strong>输出:</strong> 0 
<strong>解释:</strong> 在这个情况下, 没有交易完成, 所以最大利润为 0。</pre>
</div></div>"
124,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个<strong>非空</strong>二叉树，返回其最大路径和。</p>
<p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径<strong>至少包含一个</strong>节点，且不需要经过根节点。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [1,2,3]

       <strong>1</strong>
      <strong>/ \</strong>
     <strong>2</strong>   <strong>3</strong>

<strong>输出:</strong> 6
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [-10,9,20,null,null,15,7]

   -10
   / \
  9  <strong>20</strong>
    <strong>/  \</strong>
   <strong>15   7</strong>

<strong>输出:</strong> 42</pre>
</div></div>"
125,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> ""A man, a plan, a canal: Panama""
<strong>输出:</strong> true
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> ""race a car""
<strong>输出:</strong> false
</pre>
</div></div>"
126,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典 <em>wordList</em>，找出所有从 <em>beginWord </em>到 <em>endWord </em>的最短转换序列。转换需遵循如下规则：</p>
<ol>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ol>
<p><strong>说明:</strong></p>
<ul>
<li>如果不存在这样的转换序列，返回一个空列表。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 <em>beginWord</em> 和 <em>endWord </em>是非空的，且二者不相同。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong>
beginWord = ""hit"",
endWord = ""cog"",
wordList = [""hot"",""dot"",""dog"",""lot"",""log"",""cog""]

<strong>输出:</strong>
[
  [""hit"",""hot"",""dot"",""dog"",""cog""],
  [""hit"",""hot"",""lot"",""log"",""cog""]
]
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong>
beginWord = ""hit""
endWord = ""cog""
wordList = [""hot"",""dot"",""dog"",""lot"",""log""]

<strong>输出: </strong>[]

<strong>解释:</strong> <em>endWord</em> ""cog"" 不在字典中，所以不存在符合要求的转换序列。</pre>
</div></div>"
127,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定两个单词（<em>beginWord </em>和 <em>endWord</em>）和一个字典，找到从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p>
<ol>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ol>
<p><strong>说明:</strong></p>
<ul>
<li>如果不存在这样的转换序列，返回 0。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 <em>beginWord</em> 和 <em>endWord </em>是非空的，且二者不相同。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong>
beginWord = ""hit"",
endWord = ""cog"",
wordList = [""hot"",""dot"",""dog"",""lot"",""log"",""cog""]

<strong>输出: </strong>5

<strong>解释: </strong>一个最短转换序列是 ""hit"" -&gt; ""hot"" -&gt; ""dot"" -&gt; ""dog"" -&gt; ""cog"",
     返回它的长度 5。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong>
beginWord = ""hit""
endWord = ""cog""
wordList = [""hot"",""dot"",""dog"",""lot"",""log""]

<strong>输出:</strong> 0

<strong>解释:</strong> <em>endWord</em> ""cog"" 不在字典中，所以无法进行转换。</pre>
</div></div>"
128,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个未排序的整数数组，找出最长连续序列的长度。</p>
<p>要求算法的时间复杂度为 <em>O(n)</em>。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> [100, 4, 200, 1, 3, 2]
<strong>输出:</strong> 4
<strong>解释:</strong> 最长连续序列是 <code>[1, 2, 3, 4]。它的长度为 4。</code></pre>
</div></div>"
129,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二叉树，它的每个结点都存放一个 <code>0-9</code> 的数字，每条从根到叶子节点的路径都代表一个数字。</p>
<p>例如，从根到叶子节点路径 <code>1-&gt;2-&gt;3</code> 代表数字 <code>123</code>。</p>
<p>计算从根到叶子节点生成的所有数字之和。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [1,2,3]
    1
   / \
  2   3
<strong>输出:</strong> 25
<strong>解释:</strong>
从根到叶子节点路径 <code>1-&gt;2</code> 代表数字 <code>12</code>.
从根到叶子节点路径 <code>1-&gt;3</code> 代表数字 <code>13</code>.
因此，数字总和 = 12 + 13 = <code>25</code>.</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
<strong>输出:</strong> 1026
<strong>解释:</strong>
从根到叶子节点路径 <code>4-&gt;9-&gt;5</code> 代表数字 495.
从根到叶子节点路径 <code>4-&gt;9-&gt;1</code> 代表数字 491.
从根到叶子节点路径 <code>4-&gt;0</code> 代表数字 40.
因此，数字总和 = 495 + 491 + 40 = <code>1026</code>.</pre>
</div></div>"
130,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个二维的矩阵，包含 <code>'X'</code> 和 <code>'O'</code>（<strong>字母 O</strong>）。</p>
<p>找到所有被 <code>'X'</code> 围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code> 填充。</p>
<p><strong>示例:</strong></p>
<pre>X X X X
X O O X
X X O X
X O X X
</pre>
<p>运行你的函数后，矩阵变为：</p>
<pre>X X X X
X X X X
X X X X
X O X X
</pre>
<p><strong>解释:</strong></p>
<p>被围绕的区间不会存在于边界上，换句话说，任何边界上的 <code>'O'</code> 都不会被填充为 <code>'X'</code>。 任何不在边界上，或不与边界上的 <code>'O'</code> 相连的 <code>'O'</code> 最终都会被填充为 <code>'X'</code>。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</p>
</div></div>"
131,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串 <em>s</em>，将<em> s </em>分割成一些子串，使每个子串都是回文串。</p>
<p>返回 <em>s</em> 所有可能的分割方案。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> ""aab""
<strong>输出:</strong>
[
  [""aa"",""b""],
  [""a"",""a"",""b""]
]</pre>
</div></div>"
132,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。</p>
<p>返回符合要求的最少分割次数。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> ""aab""
<strong>输出:</strong> 1
<strong>解释: </strong>进行一次分割就可将 <em>s </em>分割成 [""aa"",""b""] 这样两个回文子串。
</pre>
</div></div>"
133,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>克隆一张无向图，图中的每个节点包含一个 <code>label</code> （标签）和一个 <code>neighbors</code> （邻接点）列表 。</p>
<p><strong>OJ的无向图序列化：</strong></p>
<p>节点被唯一标记。</p>
<p>我们用 <code>#</code> 作为每个节点的分隔符，用 <code>,</code> 作为节点标签和邻接点的分隔符。</p>
<p>例如，序列化无向图 <code>{0,1,2#1,2#2,2}</code>。</p>
<p>该图总共有三个节点, 被两个分隔符  <code>#</code> 分为三部分。 </p>
<ol>
<li>第一个节点的标签为 <code>0</code>，存在从节点 <code>0</code> 到节点 <code>1</code> 和节点 <code>2</code> 的两条边。</li>
<li>第二个节点的标签为 <code>1</code>，存在从节点 <code>1</code> 到节点 <code>2</code> 的一条边。</li>
<li>第三个节点的标签为 <code>2</code>，存在从节点 <code>2</code> 到节点 <code>2</code> (本身) 的一条边，从而形成自环。</li>
</ol>
<p>我们将图形可视化如下：</p>
<pre>       1
      / \
     /   \
    0 --- 2
         / \
         \_/
</pre>
</div></div>"
134,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>在一条环路上有 <em>N</em> 个加油站，其中第 <em>i</em> 个加油站有汽油 <code>gas[i]</code><em> </em>升。</p>
<p>你有一辆油箱容量无限的的汽车，从第<em> i </em>个加油站开往第<em> i+1 </em>个加油站需要消耗汽油 <code>cost[i]</code><em> </em>升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p><strong>说明:</strong> </p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

<strong>输出:</strong> 3

<strong>解释:
</strong>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 
gas  = [2,3,4]
cost = [3,4,3]

<strong>输出:</strong> -1

<strong>解释:
</strong>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。</pre>
</div></div>"
135,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>老师想给孩子们分发糖果，有 <em>N</em> 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 1 个糖果。</li>
<li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li>
</ul>
<p>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [1,0,2]
<strong>输出:</strong> 5
<strong>解释:</strong> 你可以分别给这三个孩子分发 2、1、2 颗糖果。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [1,2,2]
<strong>输出:</strong> 4
<strong>解释:</strong> 你可以分别给这三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</pre>
</div></div>"
136,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong></p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [2,2,1]
<strong>输出:</strong> 1
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [4,1,2,1,2]
<strong>输出:</strong> 4</pre>
</div></div>"
137,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p>
<p><strong>说明：</strong></p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [2,2,3,2]
<strong>输出:</strong> 3
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [0,1,0,1,0,1,99]
<strong>输出:</strong> 99</pre>
</div></div>"
138,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p>
<p>要求返回这个链表的深度拷贝。 </p>
</div></div>"
139,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，判定 <em>s</em> 是否可以被空格拆分为一个或多个在字典中出现的单词。</p>
<p><strong>说明：</strong></p>
<ul>
<li>拆分时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p><strong>示例 1：</strong></p>
<pre><strong>输入:</strong> s = ""leetcode"", wordDict = [""leet"", ""code""]
<strong>输出:</strong> true
<strong>解释:</strong> 返回 true 因为 ""leetcode"" 可以被拆分成 ""leet code""。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入:</strong> s = ""applepenapple"", wordDict = [""apple"", ""pen""]
<strong>输出:</strong> true
<strong>解释:</strong> 返回 true 因为 <code>""</code>applepenapple<code>""</code> 可以被拆分成 <code>""</code>apple pen apple<code>""</code>。
     注意你可以重复使用字典中的单词。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入:</strong> s = ""catsandog"", wordDict = [""cats"", ""dog"", ""sand"", ""and"", ""cat""]
<strong>输出:</strong> false
</pre>
</div></div>"
140,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p>
<p><strong>说明：</strong></p>
<ul>
<li>分隔时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p><strong>示例 1：</strong></p>
<pre><strong>输入:
</strong>s = ""<code>catsanddog</code>""
wordDict = <code>[""cat"", ""cats"", ""and"", ""sand"", ""dog""]</code>
<strong>输出:
</strong><code>[
  ""cats and dog"",
  ""cat sand dog""
]</code>
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入:
</strong>s = ""pineapplepenapple""
wordDict = [""apple"", ""pen"", ""applepen"", ""pine"", ""pineapple""]
<strong>输出:
</strong>[
  ""pine apple pen apple"",
  ""pineapple pen apple"",
  ""pine applepen apple""
]
<strong>解释:</strong> 注意你可以重复使用字典中的单词。
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入:
</strong>s = ""catsandog""
wordDict = [""cats"", ""dog"", ""sand"", ""and"", ""cat""]
<strong>输出:
</strong>[]
</pre>
</div></div>"
