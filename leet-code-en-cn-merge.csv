num,title_en_x,link_en,difficulty_x,acp_x,title_en2,title_cn,link_cn,difficulty_y,acp_y,title_en_y,question_descriptions
1,Two Sum,https://leetcode.com/problems/two-sum/description/,Easy,38.3%,Two Sum,两数之和,https://leetcode-cn.com/problems/two-sum/description/,简单,45.0%,Two Sum,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个整数数组和一个目标值，找出数组中和为目标值的<strong>两个</strong>数。</p>
<p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p>
<p><strong>示例:</strong></p>
<pre>给定 nums = [2, 7, 11, 15], target = 9

因为 nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9
所以返回 [<strong>0, 1</strong>]
</pre>
</div></div>"
2,Add Two Numbers,https://leetcode.com/problems/add-two-numbers/description/,Medium,28.8%,Add Two Numbers,两数相加,https://leetcode-cn.com/problems/add-two-numbers/description/,中等,28.6%,Add Two Numbers,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定两个<strong>非空</strong>链表来表示两个非负整数。位数按照<strong>逆序</strong>方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
<strong>输出：</strong>7 -&gt; 0 -&gt; 8
<strong>原因：</strong>342 + 465 = 807
</pre>
</div></div>"
3,Longest Substring Without Repeating Characters,https://leetcode.com/problems/longest-substring-without-repeating-characters/description/,Medium,24.8%,Longest Substring Without Repeating Characters,无重复字符的最长子串,https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/,中等,23.1%,Longest Substring Without Repeating Characters,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串，找出不含有重复字符的<strong>最长子串</strong>的长度。</p>
<p><strong>示例：</strong></p>
<p>给定 <code>""abcabcbb""</code> ，没有重复字符的最长子串是 <code>""abc""</code> ，那么长度就是3。</p>
<p>给定 <code>""bbbbb""</code> ，最长的子串就是 <code>""b""</code> ，长度是1。</p>
<p>给定 <code>""pwwkew""</code> ，最长子串是 <code>""wke""</code> ，长度是3。请注意答案必须是一个<strong>子串</strong>，<code>""pwke""</code> 是 <em>子序列  </em>而不是子串。</p>
</div></div>"
4,Median of Two Sorted Arrays,https://leetcode.com/problems/median-of-two-sorted-arrays/description/,Hard,23.3%,Median of Two Sorted Arrays,两个排序数组的中位数,https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/,困难,30.2%,Median of Two Sorted Arrays,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定两个大小为 m 和 n 的有序数组 <strong>nums1 </strong>和 <strong>nums2 </strong>。</p>
<p>请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。</p>
<p><strong>示例 1:</strong></p>
<pre>nums1 = [1, 3]
nums2 = [2]

中位数是 2.0
</pre>
<p><strong>示例 2:</strong></p>
<pre>nums1 = [1, 2]
nums2 = [3, 4]

中位数是 (2 + 3)/2 = 2.5
</pre>
</div></div>"
5,Longest Palindromic Substring,https://leetcode.com/problems/longest-palindromic-substring/description/,Medium,25.4%,Longest Palindromic Substring,最长回文子串,https://leetcode-cn.com/problems/longest-palindromic-substring/description/,中等,23.2%,Longest Palindromic Substring,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串 <strong>s</strong>，找到 <strong>s</strong> 中最长的回文子串。你可以假设 <strong>s </strong>的最大长度为1000。</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入:</strong> ""babad""
<strong>输出:</strong> ""bab""
<strong>注意:</strong> ""aba""也是一个有效答案。
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入:</strong> ""cbbd""
<strong>输出:</strong> ""bb""
</pre>
</div></div>"
6,ZigZag Conversion,https://leetcode.com/problems/zigzag-conversion/description/,Medium,27.7%,ZigZag Conversion,Z字形变换,https://leetcode-cn.com/problems/zigzag-conversion/description/,中等,32.0%,ZigZag Conversion,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>将字符串 <code>""PAYPALISHIRING""</code> 以Z字形排列成给定的行数：</p>
<pre>P   A   H   N
A P L S I I G
Y   I   R
</pre>
<p>之后从左往右，逐行读取字符：<code>""PAHNAPLSIIGYIR""</code></p>
<p>实现一个将字符串进行指定行数变换的函数:</p>
<pre>string convert(string s, int numRows);</pre>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> s = ""PAYPALISHIRING"", numRows = 3
<strong>输出:</strong> ""PAHNAPLSIIGYIR""
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> s = ""PAYPALISHIRING"", numRows = 4
<strong>输出:</strong> ""PINALSIGYAHRPI""
<strong>解释:</strong>

P     I    N
A   L S  I G
Y A   H R
P     I</pre>
</div></div>"
7,Reverse Integer,https://leetcode.com/problems/reverse-integer/description/,Easy,24.4%,Reverse Integer,反转整数,https://leetcode-cn.com/problems/reverse-integer/description/,简单,27.0%,Reverse Integer,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个 32 位有符号整数，将整数中的数字进行反转。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 123
<strong>输出:</strong> 321
</pre>
<p><strong> 示例 2:</strong></p>
<pre><strong>输入:</strong> -123
<strong>输出:</strong> -321
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> 120
<strong>输出:</strong> 21
</pre>
<p><strong>注意:</strong></p>
<p>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2<sup>31</sup>,  2<sup>31 </sup>− 1]。根据这个假设，如果反转后的整数溢出，则返回 0。</p>
</div></div>"
8,String to Integer (atoi),https://leetcode.com/problems/string-to-integer-atoi/description/,Medium,14.1%,String to Integer (atoi),字符串转整数 (atoi),https://leetcode-cn.com/problems/string-to-integer-atoi/description/,中等,15.8%,String to Integer (atoi),"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>实现 <code>atoi</code>，将字符串转为整数。</p>
<p>在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。</p>
<p>当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。</p>
<p>若函数不能执行有效的转换，返回 0。</p>
<p><strong>说明：</strong></p>
<p>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2<sup>31</sup>,  2<sup>31 </sup>− 1]。如果数值超过可表示的范围，则返回  INT_MAX (2<sup>31 </sup>− 1) 或 INT_MIN (−2<sup>31</sup>) 。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> ""42""
<strong>输出:</strong> 42
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> ""   -42""
<strong>输出:</strong> -42
<strong>解释: </strong>第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> ""4193 with words""
<strong>输出:</strong> 4193
<strong>解释:</strong> 转换截止于数字 '3' ，因为它的下一个字符不为数字。
</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong> ""words and 987""
<strong>输出:</strong> 0
<strong>解释:</strong> 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。</pre>
<p><strong>示例 5:</strong></p>
<pre><strong>输入:</strong> ""-91283472332""
<strong>输出:</strong> -2147483648
<strong>解释:</strong> 数字 ""-91283472332"" 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−2<sup>31</sup>) 。
</pre>
</div></div>"
9,Palindrome Number,https://leetcode.com/problems/palindrome-number/description/,Easy,36.5%,Palindrome Number,回文数,https://leetcode-cn.com/problems/palindrome-number/description/,简单,48.6%,Palindrome Number,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 121
<strong>输出:</strong> true
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> -121
<strong>输出:</strong> false
<strong>解释:</strong> 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> 10
<strong>输出:</strong> false
<strong>解释:</strong> 从右向左读, 为 01 。因此它不是一个回文数。
</pre>
<p><strong>进阶:</strong></p>
<p>你能不将整数转为字符串来解决这个问题吗？</p>
</div></div>"
10,Regular Expression Matching,https://leetcode.com/problems/regular-expression-matching/description/,Hard,24.3%,Regular Expression Matching,正则表达式匹配,https://leetcode-cn.com/problems/regular-expression-matching/description/,困难,17.1%,Regular Expression Matching,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>)。实现支持 <code>'.'</code> 和 <code>'*'</code> 的正则表达式匹配。</p>
<pre>'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
</pre>
<p>匹配应该覆盖<strong>整个</strong>字符串 (<code>s</code>) ，而不是部分字符串。</p>
<p><strong>说明:</strong></p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong>
s = ""aa""
p = ""a""
<strong>输出:</strong> false
<strong>解释:</strong> ""a"" 无法匹配 ""aa"" 整个字符串。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong>
s = ""aa""
p = ""a*""
<strong>输出:</strong> true
<strong>解释:</strong> '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 ""aa""。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong>
s = ""ab""
p = "".*""
<strong>输出:</strong> true
<strong>解释:</strong> "".*"" 表示可匹配零个或多个('*')任意字符('.')。
</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong>
s = ""aab""
p = ""c*a*b""
<strong>输出:</strong> true
<strong>解释:</strong> 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 ""aab""。
</pre>
<p><strong>示例 5:</strong></p>
<pre><strong>输入:</strong>
s = ""mississippi""
p = ""mis*is*p*.""
<strong>输出:</strong> false</pre>
</div></div>"
11,Container With Most Water,https://leetcode.com/problems/container-with-most-water/description/,Medium,37.2%,Container With Most Water,盛最多水的容器,https://leetcode-cn.com/problems/container-with-most-water/description/,中等,29.9%,Container With Most Water,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定 <em>n</em> 个非负整数 <em>a</em><sub>1</sub>，<em>a</em><sub>2，</sub>...，<em>a</em><sub>n，</sub>每个数代表坐标中的一个点 (<em>i</em>, <em>a<sub>i</sub></em>) 。画 <em>n</em> 条垂直线，使得垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>a<sub>i</sub></em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p>
<p><strong>注意：</strong>你不能倾斜容器，<em>n</em> 至少是2。</p>
</div></div>"
12,Integer to Roman,https://leetcode.com/problems/integer-to-roman/description/,Medium,46.6%,Integer to Roman,整数转罗马数字,https://leetcode-cn.com/problems/integer-to-roman/description/,中等,54.2%,Integer to Roman,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<pre><strong>字符</strong>          <strong>数值</strong>
I             1
V             5
X             10
L             50
C             100
D             500
M             1000</pre>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 3
<strong>输出:</strong> ""III""</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 4
<strong>输出:</strong> ""IV""</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> 9
<strong>输出:</strong> ""IX""</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong> 58
<strong>输出:</strong> ""LVIII""
<strong>解释:</strong> C = 100, L = 50, XXX = 30, III = 3.
</pre>
<p><strong>示例 5:</strong></p>
<pre><strong>输入:</strong> 1994
<strong>输出:</strong> ""MCMXCIV""
<strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</pre>
</div></div>"
13,Roman to Integer,https://leetcode.com/problems/roman-to-integer/description/,Easy,48.5%,Roman to Integer,罗马数字转整数,https://leetcode-cn.com/problems/roman-to-integer/description/,简单,53.4%,Roman to Integer,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>罗马数字包含以下七种字符：<code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<pre><strong>字符</strong>          <strong>数值</strong>
I             1
V             5
X             10
L             50
C             100
D             500
M             1000</pre>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> ""III""
<strong>输出:</strong> 3</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> ""IV""
<strong>输出:</strong> 4</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> ""IX""
<strong>输出:</strong> 9</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong> ""LVIII""
<strong>输出:</strong> 58
<strong>解释:</strong> C = 100, L = 50, XXX = 30, III = 3.
</pre>
<p><strong>示例 5:</strong></p>
<pre><strong>输入:</strong> ""MCMXCIV""
<strong>输出:</strong> 1994
<strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</pre>
</div></div>"
14,Longest Common Prefix,https://leetcode.com/problems/longest-common-prefix/description/,Easy,31.7%,Longest Common Prefix,最长公共前缀,https://leetcode-cn.com/problems/longest-common-prefix/description/,简单,28.3%,Longest Common Prefix,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>""""</code>。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入: </strong>[""flower"",""flow"",""flight""]
<strong>输出:</strong> ""fl""
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入: </strong>[""dog"",""racecar"",""car""]
<strong>输出:</strong> """"
<strong>解释:</strong> 输入不存在公共前缀。
</pre>
<p><strong>说明:</strong></p>
<p>所有输入只包含小写字母 <code>a-z</code> 。</p>
</div></div>"
15,3Sum,https://leetcode.com/problems/3sum/description/,Medium,21.8%,3Sum,三数之和,https://leetcode-cn.com/problems/3sum/description/,中等,14.2%,3Sum,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c = </em>0 ？找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<pre>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</pre>
</div></div>"
16,3Sum Closest,https://leetcode.com/problems/3sum-closest/description/,Medium,31.9%,3Sum Closest,最接近的三数之和,https://leetcode-cn.com/problems/3sum-closest/description/,中等,32.8%,3Sum Closest,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code><em> </em>和 一个目标值 <code>target</code>。找出 <code>nums</code><em> </em>中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<pre>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
</pre>
</div></div>"
17,Letter Combinations of a Phone Number,https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/,Medium,36.9%,Letter Combinations of a Phone Number,电话号码的字母组合,https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/description/,中等,41.6%,Letter Combinations of a Phone Number,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src=""http://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png""/></p>
<p><strong>示例:</strong></p>
<pre><strong>输入：</strong>""23""
<strong>输出：</strong>[""ad"", ""ae"", ""af"", ""bd"", ""be"", ""bf"", ""cd"", ""ce"", ""cf""].
</pre>
<p><strong>说明:</strong><br/>
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
</div></div>"
18,4Sum,https://leetcode.com/problems/4sum/description/,Medium,27.7%,4Sum,四数之和,https://leetcode-cn.com/problems/4sum/description/,中等,29.2%,4Sum,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 <em>a，</em><em>b，c</em> 和 <em>d</em> ，使得 <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p>
<p><strong>注意：</strong></p>
<p>答案中不可以包含重复的四元组。</p>
<p><strong>示例：</strong></p>
<pre>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
</pre>
</div></div>"
19,Remove Nth Node From End of List,https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/,Medium,33.9%,Remove Nth Node From End of List,删除链表的倒数第N个节点,https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/description/,中等,28.0%,Remove Nth Node From End of List,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个链表，删除链表的倒数第 <em>n </em>个节点，并且返回链表的头结点。</p>
<p><strong>示例：</strong></p>
<pre>给定一个链表: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, 和 <strong><em>n</em> = 2</strong>.

当删除了倒数第二个节点后，链表变为 <strong>1-&gt;2-&gt;3-&gt;5</strong>.
</pre>
<p><strong>说明：</strong></p>
<p>给定的 <em>n</em> 保证是有效的。</p>
<p><strong>进阶：</strong></p>
<p>你能尝试使用一趟扫描实现吗？</p>
</div></div>"
20,Valid Parentheses,https://leetcode.com/problems/valid-parentheses/description/,Easy,34.2%,Valid Parentheses,有效的括号,https://leetcode-cn.com/problems/valid-parentheses/description/,简单,30.5%,Valid Parentheses,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> ""()""
<strong>输出:</strong> true
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> ""()[]{}""
<strong>输出:</strong> true
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> ""(]""
<strong>输出:</strong> false
</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong> ""([)]""
<strong>输出:</strong> false
</pre>
<p><strong>示例 5:</strong></p>
<pre><strong>输入:</strong> ""{[]}""
<strong>输出:</strong> true</pre>
</div></div>"
21,Merge Two Sorted Lists,https://leetcode.com/problems/merge-two-sorted-lists/description/,Easy,41.7%,Merge Two Sorted Lists,合并两个有序链表,https://leetcode-cn.com/problems/merge-two-sorted-lists/description/,简单,48.0%,Merge Two Sorted Lists,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例：</strong></p>
<pre><strong>输入：</strong>1-&gt;2-&gt;4, 1-&gt;3-&gt;4
<strong>输出：</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
</pre>
</div></div>"
22,Generate Parentheses,https://leetcode.com/problems/generate-parentheses/description/,Medium,48.6%,Generate Parentheses,括号生成,https://leetcode-cn.com/problems/generate-parentheses/description/,中等,60.5%,Generate Parentheses,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给出 <em>n</em> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。</p>
<p>例如，给出 <em>n </em>=<em> </em>3，生成结果为：</p>
<pre>[
  ""((()))"",
  ""(()())"",
  ""(())()"",
  ""()(())"",
  ""()()()""
]
</pre>
</div></div>"
23,Merge k Sorted Lists,https://leetcode.com/problems/merge-k-sorted-lists/description/,Hard,28.7%,Merge k Sorted Lists,合并K个排序链表,https://leetcode-cn.com/problems/merge-k-sorted-lists/description/,困难,35.5%,Merge k Sorted Lists,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>合并 <em>k </em>个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong>
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
<strong>输出:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</pre>
</div></div>"
24,Swap Nodes in Pairs,https://leetcode.com/problems/swap-nodes-in-pairs/description/,Medium,39.6%,Swap Nodes in Pairs,两两交换链表中的节点,https://leetcode-cn.com/problems/swap-nodes-in-pairs/description/,中等,47.9%,Swap Nodes in Pairs,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p><strong>示例:</strong></p>
<pre>给定 <code>1-&gt;2-&gt;3-&gt;4</code>, 你应该返回 <code>2-&gt;1-&gt;4-&gt;3</code>.</pre>
<p><strong>说明:</strong></p>
<ul>
<li>你的算法只能使用常数的额外空间。</li>
<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</li>
</ul>
</div></div>"
25,Reverse Nodes in k-Group,https://leetcode.com/problems/reverse-nodes-in-k-group/description/,Hard,32.1%,Reverse Nodes in k-Group,k个一组翻转链表,https://leetcode-cn.com/problems/reverse-nodes-in-k-group/description/,困难,42.3%,Reverse Nodes in k-Group,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给出一个链表，每 <em>k </em>个节点一组进行翻转，并返回翻转后的链表。</p>
<p><em>k </em>是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <em>k </em>的整数倍，那么将最后剩余节点保持原有顺序。</p>
<p><strong>示例 :</strong></p>
<p>给定这个链表：<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>当 <em>k </em>= 2 时，应当返回: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>当 <em>k </em>= 3 时，应当返回: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p><strong>说明 :</strong></p>
<ul>
<li>你的算法只能使用常数的额外空间。</li>
<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</li>
</ul>
</div></div>"
26,Remove Duplicates from Sorted Array,https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/,Easy,36.8%,Remove Duplicates from Sorted Array,删除排序数组中的重复项,https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/description/,简单,37.8%,Remove Duplicates from Sorted Array,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个排序数组，你需要在<strong><a href=""http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a></strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong><a href=""https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a>修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1:</strong></p>
<pre>给定数组 <em>nums</em> = <strong>[1,1,2]</strong>, 

函数应该返回新的长度 <strong>2</strong>, 并且原数组 <em>nums </em>的前两个元素被修改为 <strong><code>1</code></strong>, <strong><code>2</code></strong>。 

你不需要考虑数组中超出新长度后面的元素。</pre>
<p><strong>示例 2:</strong></p>
<pre>给定<em> nums </em>= <strong>[0,0,1,1,1,2,2,3,3,4]</strong>,

函数应该返回新的长度 <strong>5</strong>, 并且原数组 <em>nums </em>的前五个元素被修改为 <strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>2</code></strong>, <strong><code>3</code></strong>, <strong><code>4</code></strong>。

你不需要考虑数组中超出新长度后面的元素。
</pre>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre>// <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中<strong>该长度范围内</strong>的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</pre>
</div></div>"
27,Remove Element,https://leetcode.com/problems/remove-element/description/,Easy,41.1%,Remove Element,移除元素,https://leetcode-cn.com/problems/remove-element/description/,简单,47.5%,Remove Element,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个数组 <em>nums </em>和一个值 <em>val</em>，你需要<strong><a href=""https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a></strong>移除所有数值等于 <em>val </em>的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在<strong><a href=""https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a>修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 1:</strong></p>
<pre>给定 <em>nums</em> = <strong>[3,2,2,3]</strong>, <em>val</em> = <strong>3</strong>,

函数应该返回新的长度 <strong>2</strong>, 并且 <em>nums </em>中的前两个元素均为 <strong>2</strong>。

你不需要考虑数组中超出新长度后面的元素。
</pre>
<p><strong>示例 2:</strong></p>
<pre>给定 <em>nums</em> = <strong>[0,1,2,2,3,0,4,2]</strong>, <em>val</em> = <strong>2</strong>,

函数应该返回新的长度 <strong><code>5</code></strong>, 并且 <em>nums </em>中的前五个元素为 <strong><code>0</code></strong>, <strong><code>1</code></strong>, <strong><code>3</code></strong>, <strong><code>0</code></strong>, <strong>4</strong>。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。
</pre>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>“引用”</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre>// <strong>nums</strong> 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中<strong>该长度范围内</strong>的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</pre>
</div></div>"
28,Implement strStr(),https://leetcode.com/problems/implement-strstr/description/,Easy,29.2%,Implement strStr(),实现strStr(),https://leetcode-cn.com/problems/implement-strstr/description/,简单,33.7%,Implement strStr(),"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>实现 <a href=""https://baike.baidu.com/item/strstr/811469"" target=""_blank"">strStr()</a> 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  <strong>-1</strong>。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> haystack = ""hello"", needle = ""ll""
<strong>输出:</strong> 2
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> haystack = ""aaaaa"", needle = ""bba""
<strong>输出:</strong> -1
</pre>
<p><strong>说明:</strong></p>
<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 <a href=""https://baike.baidu.com/item/strstr/811469"" target=""_blank"">strstr()</a> 以及 Java的 <a href=""https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)"" target=""_blank"">indexOf()</a> 定义相符。</p>
</div></div>"
29,Divide Two Integers,https://leetcode.com/problems/divide-two-integers/description/,Medium,15.7%,Divide Two Integers,两数相除,https://leetcode-cn.com/problems/divide-two-integers/description/,中等,14.2%,Divide Two Integers,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定两个整数，被除数 <code>dividend</code> 和除数 <code>divisor</code>。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 <code>dividend</code> 除以除数 <code>divisor</code> 得到的商。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> dividend = 10, divisor = 3
<strong>输出:</strong> 3</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> dividend = 7, divisor = -3
<strong>输出:</strong> -2</pre>
<p><strong>说明:</strong></p>
<ul>
<li>被除数和除数均为 32 位有符号整数。</li>
<li>除数不为 0。</li>
<li>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2<sup>31</sup>,  2<sup>31 </sup>− 1]。本题中，如果除法结果溢出，则返回 2<sup>31 </sup>− 1。</li>
</ul>
</div></div>"
30,Substring with Concatenation of All Words,https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/,Hard,22.3%,Substring with Concatenation of All Words,与所有单词相关联的字串,https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/description/,困难,17.9%,Substring with Concatenation of All Words,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串 <strong>s </strong>和一些长度相同的单词 <strong>words。</strong>在<strong> s </strong>中找出可以恰好串联 <strong>words </strong>中所有单词的子串的起始位置。</p>
<p>注意子串要与 <strong>words </strong>中的单词完全匹配，中间不能有其他字符，但不需要考虑 <strong>words </strong>中单词串联的顺序。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:
  s =</strong> ""barfoothefoobarman"",
<strong>  words = </strong>[""foo"",""bar""]
<strong>输出:</strong> <code>[0,9]</code>
<strong>解释:</strong> 从索引 0 和 9 开始的子串分别是 ""barfoor"" 和 ""foobar"" 。
输出的顺序不重要, [9,0] 也是有效答案。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:
  s =</strong> ""wordgoodstudentgoodword"",
<strong>  words = </strong>[""word"",""student""]
<strong>输出:</strong> <code>[]</code>
</pre>
</div></div>"
31,Next Permutation,https://leetcode.com/problems/next-permutation/description/,Medium,29.1%,Next Permutation,下一个排列,https://leetcode-cn.com/problems/next-permutation/description/,中等,27.6%,Next Permutation,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须<strong><a href=""https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a></strong>修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br/>
<code>1,2,3</code> → <code>1,3,2</code><br/>
<code>3,2,1</code> → <code>1,2,3</code><br/>
<code>1,1,5</code> → <code>1,5,1</code></p>
</div></div>"
32,Longest Valid Parentheses,https://leetcode.com/problems/longest-valid-parentheses/description/,Hard,23.3%,Longest Valid Parentheses,最长有效括号,https://leetcode-cn.com/problems/longest-valid-parentheses/description/,困难,19.5%,Longest Valid Parentheses,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长的包含有效括号的子串的长度。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> ""(()""
<strong>输出:</strong> 2
<strong>解释:</strong> 最长有效括号子串为 <code>""()""</code>
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> ""<code>)()())</code>""
<strong>输出:</strong> 4
<strong>解释:</strong> 最长有效括号子串为 <code>""()()""</code>
</pre>
</div></div>"
33,Search in Rotated Sorted Array,https://leetcode.com/problems/search-in-rotated-sorted-array/description/,Medium,31.9%,Search in Rotated Sorted Array,搜索旋转排序数组,https://leetcode-cn.com/problems/search-in-rotated-sorted-array/description/,中等,30.8%,Search in Rotated Sorted Array,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 <code>[0,1,2,4,5,6,7]</code> 可能变为 <code>[4,5,6,7,0,1,2]</code> )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 <code>-1</code> 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> nums = [<code>4,5,6,7,0,1,2]</code>, target = 0
<strong>输出:</strong> 4
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> nums = [<code>4,5,6,7,0,1,2]</code>, target = 3
<strong>输出:</strong> -1</pre>
</div></div>"
34,Search for a Range,https://leetcode.com/problems/search-for-a-range/description/,Medium,31.7%,Search for a Range,搜索范围,https://leetcode-cn.com/problems/search-for-a-range/description/,中等,32.1%,Search for a Range,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p>
<p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> nums = [<code>5,7,7,8,8,10]</code>, target = 8
<strong>输出:</strong> [3,4]</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> nums = [<code>5,7,7,8,8,10]</code>, target = 6
<strong>输出:</strong> [-1,-1]</pre>
</div></div>"
35,Search Insert Position,https://leetcode.com/problems/search-insert-position/description/,Easy,40.1%,Search Insert Position,搜索插入位置,https://leetcode-cn.com/problems/search-insert-position/description/,简单,40.2%,Search Insert Position,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [1,3,5,6], 5
<strong>输出:</strong> 2
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [1,3,5,6], 2
<strong>输出:</strong> 1
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> [1,3,5,6], 7
<strong>输出:</strong> 4
</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong> [1,3,5,6], 0
<strong>输出:</strong> 0
</pre>
</div></div>"
36,Valid Sudoku,https://leetcode.com/problems/valid-sudoku/description/,Medium,38.1%,Valid Sudoku,有效的数独,https://leetcode-cn.com/problems/valid-sudoku/description/,中等,45.6%,Valid Sudoku,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>判断一个 9x9 的数独是否有效。只需要<strong>根据以下规则</strong>，验证已经填入的数字是否有效即可。</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li>
</ol>
<p><img src=""https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png"" style=""height: 250px; width: 250px;""/></p>
<p><small>上图是一个部分填充的有效的数独。</small></p>
<p>数独部分空格内已填入了数字，空白格用 <code>'.'</code> 表示。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong>
[
  [""5"",""3"",""."",""."",""7"",""."",""."",""."","".""],
  [""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""],
  [""."",""9"",""8"",""."",""."",""."",""."",""6"","".""],
  [""8"",""."",""."",""."",""6"",""."",""."",""."",""3""],
  [""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""],
  [""7"",""."",""."",""."",""2"",""."",""."",""."",""6""],
  [""."",""6"",""."",""."",""."",""."",""2"",""8"","".""],
  [""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""],
  [""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]
]
<strong>输出:</strong> true
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong>
[
  [""8"",""3"",""."",""."",""7"",""."",""."",""."","".""],
  [""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""],
  [""."",""9"",""8"",""."",""."",""."",""."",""6"","".""],
  [""8"",""."",""."",""."",""6"",""."",""."",""."",""3""],
  [""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""],
  [""7"",""."",""."",""."",""2"",""."",""."",""."",""6""],
  [""."",""6"",""."",""."",""."",""."",""2"",""8"","".""],
  [""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""],
  [""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]
]
<strong>输出:</strong> false
<strong>解释:</strong> 除了第一行的第一个数字从<strong> 5</strong> 改为 <strong>8 </strong>以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</pre>
<p><strong>说明:</strong></p>
<ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>给定数独序列只包含数字 <code>1-9</code> 和字符 <code>'.'</code> 。</li>
<li>给定数独永远是 <code>9x9</code> 形式的。</li>
</ul>
</div></div>"
37,Sudoku Solver,https://leetcode.com/problems/sudoku-solver/description/,Hard,32.5%,Sudoku Solver,解数独,https://leetcode-cn.com/problems/sudoku-solver/description/,困难,44.5%,Sudoku Solver,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>编写一个程序，通过已填充的空格来解决数独问题。</p>
<p>一个数独的解法需<strong>遵循如下规则</strong>：</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li>
</ol>
<p>空白格用 <code>'.'</code> 表示。</p>
<p><img src=""http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png""/></p>
<p><small>一个数独。</small></p>
<p><img src=""http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png""/></p>
<p><small>答案被标成红色。</small></p>
<p><strong>Note:</strong></p>
<ul>
<li>给定的数独序列只包含数字 <code>1-9</code> 和字符 <code>'.'</code> 。</li>
<li>你可以假设给定的数独只有唯一解。</li>
<li>给定数独永远是 <code>9x9</code> 形式的。</li>
</ul>
</div></div>"
38,Count and Say,https://leetcode.com/problems/count-and-say/description/,Easy,37.1%,Count and Say,报数,https://leetcode-cn.com/problems/count-and-say/description/,简单,44.7%,Count and Say,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>报数序列是指一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p>
<pre>1.     1
2.     11
3.     21
4.     1211
5.     111221
</pre>
<p><code>1</code> 被读作  <code>""one 1""</code>  (<code>""一个一""</code>) , 即 <code>11</code>。<br/>
<code>11</code> 被读作 <code>""two 1s""</code> (<code>""两个一""</code>）, 即 <code>21</code>。<br/>
<code>21</code> 被读作 <code>""one 2""</code>,  ""<code>one 1""</code> （<code>""一个二""</code> ,  <code>""一个一""</code>) , 即 <code>1211</code>。</p>
<p>给定一个正整数 <em>n</em> ，输出报数序列的第 <em>n</em> 项。</p>
<p>注意：整数顺序将表示为一个字符串。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 1
<strong>输出:</strong> ""1""
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 4
<strong>输出:</strong> ""1211""
</pre>
</div></div>"
39,Combination Sum,https://leetcode.com/problems/combination-sum/description/,Medium,42.0%,Combination Sum,组合总和,https://leetcode-cn.com/problems/combination-sum/description/,中等,57.5%,Combination Sum,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的数字可以无限制重复被选取。</p>
<p><strong>说明：</strong></p>
<ul>
<li>所有数字（包括 <code>target</code>）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> candidates = <code>[2,3,6,7], </code>target = <code>7</code>,
<strong>所求解集为:</strong>
[
  [7],
  [2,2,3]
]
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> candidates = [2,3,5]<code>, </code>target = 8,
<strong>所求解集为:</strong>
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]</pre>
</div></div>"
40,Combination Sum II,https://leetcode.com/problems/combination-sum-ii/description/,Medium,36.5%,Combination Sum II,组合总和 II,https://leetcode-cn.com/problems/combination-sum-ii/description/,中等,48.8%,Combination Sum II,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>
<p><strong>说明：</strong></p>
<ul>
<li>所有数字（包括目标数）都是正整数。</li>
<li>解集不能包含重复的组合。 </li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> candidates = <code>[10,1,2,7,6,1,5]</code>, target = <code>8</code>,
<strong>所求解集为:</strong>
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> candidates = [2,5,2,1,2], target = 5,
<strong>所求解集为:</strong>
[
  [1,2,2],
  [5]
]</pre>
</div></div>"
41,First Missing Positive,https://leetcode.com/problems/first-missing-positive/description/,Hard,26.1%,First Missing Positive,缺失的第一个正数,https://leetcode-cn.com/problems/first-missing-positive/description/,困难,28.8%,First Missing Positive,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个未排序的整数数组，找出其中没有出现的最小的正整数。</p>
<p><strong>示例 1:</strong></p>
<pre>输入: [1,2,0]
输出: 3
</pre>
<p><strong>示例 2:</strong></p>
<pre>输入: [3,4,-1,1]
输出: 2
</pre>
<p><strong>示例 3:</strong></p>
<pre>输入: [7,8,9,11,12]
输出: 1
</pre>
<p><strong>说明:</strong></p>
<p>你的算法的时间复杂度应为O(<em>n</em>)，并且只能使用常数级别的空间。</p>
</div></div>"
42,Trapping Rain Water,https://leetcode.com/problems/trapping-rain-water/description/,Hard,38.0%,Trapping Rain Water,接雨水,https://leetcode-cn.com/problems/trapping-rain-water/description/,困难,33.0%,Trapping Rain Water,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src=""/static/images/problemset/rainwatertrap.png""/></p>
<p><small>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 <strong>感谢 Marcos</strong> 贡献此图。</small></p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> [0,1,0,2,1,0,1,3,2,1,2,1]
<strong>输出:</strong> 6</pre>
</div></div>"
43,Multiply Strings,https://leetcode.com/problems/multiply-strings/description/,Medium,28.1%,Multiply Strings,字符串相乘,https://leetcode-cn.com/problems/multiply-strings/description/,中等,30.8%,Multiply Strings,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> num1 = ""2"", num2 = ""3""
<strong>输出:</strong> ""6""</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> num1 = ""123"", num2 = ""456""
<strong>输出:</strong> ""56088""</pre>
<p><strong>说明：</strong></p>
<ol>
<li><code>num1</code> 和 <code>num2</code> 的长度小于110。</li>
<li><code>num1</code> 和 <code>num2</code> 只包含数字 <code>0-9</code>。</li>
<li><code>num1</code> 和 <code>num2</code> 均不以零开头，除非是数字 0 本身。</li>
<li><strong>不能使用任何标准库的大数类型（比如 BigInteger）</strong>或<strong>直接将输入转换为整数来处理</strong>。</li>
</ol>
</div></div>"
44,Wildcard Matching,https://leetcode.com/problems/wildcard-matching/description/,Hard,21.1%,Wildcard Matching,通配符匹配,https://leetcode-cn.com/problems/wildcard-matching/description/,困难,15.5%,Wildcard Matching,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串 (<code>s</code>) 和一个字符模式 (<code>p</code>) ，实现一个支持 <code>'?'</code> 和 <code>'*'</code> 的通配符匹配。</p>
<pre>'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
</pre>
<p>两个字符串<strong>完全匹配</strong>才算匹配成功。</p>
<p><strong>说明:</strong></p>
<ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>?</code> 和 <code>*</code>。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong>
s = ""aa""
p = ""a""
<strong>输出:</strong> false
<strong>解释:</strong> ""a"" 无法匹配 ""aa"" 整个字符串。</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong>
s = ""aa""
p = ""*""
<strong>输出:</strong> true
<strong>解释:</strong> '*' 可以匹配任意字符串。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong>
s = ""cb""
p = ""?a""
<strong>输出:</strong> false
<strong>解释:</strong> '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
</pre>
<p><strong>示例 4:</strong></p>
<pre><strong>输入:</strong>
s = ""adceb""
p = ""*a*b""
<strong>输出:</strong> true
<strong>解释:</strong> 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 ""dce"".
</pre>
<p><strong>示例 5:</strong></p>
<pre><strong>输入:</strong>
s = ""acdcb""
p = ""a*c?b""
<strong>输入:</strong> false</pre>
</div></div>"
45,Jump Game II,https://leetcode.com/problems/jump-game-ii/description/,Hard,26.1%,Jump Game II,跳跃游戏 II,https://leetcode-cn.com/problems/jump-game-ii/description/,困难,24.3%,Jump Game II,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> [2,3,1,1,4]
<strong>输出:</strong> 2
<strong>解释:</strong> 跳到最后一个位置的最小跳跃数是 <code>2</code>。
     从下标为 0 跳到下标为 1 的位置，跳 <code>1</code> 步，然后跳 <code>3</code> 步到达数组的最后一个位置。
</pre>
<p><strong>说明:</strong></p>
<p>假设你总是可以到达数组的最后一个位置。</p>
</div></div>"
46,Permutations,https://leetcode.com/problems/permutations/description/,Medium,48.0%,Permutations,全排列,https://leetcode-cn.com/problems/permutations/description/,中等,61.3%,Permutations,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个<strong>没有重复</strong>数字的序列，返回其所有可能的全排列。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> [1,2,3]
<strong>输出:</strong>
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]</pre>
</div></div>"
47,Permutations II,https://leetcode.com/problems/permutations-ii/description/,Medium,35.5%,Permutations II,全排列 II,https://leetcode-cn.com/problems/permutations-ii/description/,中等,41.5%,Permutations II,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> [1,1,2]
<strong>输出:</strong>
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]</pre>
</div></div>"
48,Rotate Image,https://leetcode.com/problems/rotate-image/description/,Medium,42.4%,Rotate Image,旋转图像,https://leetcode-cn.com/problems/rotate-image/description/,中等,55.3%,Rotate Image,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个 <em>n </em>× <em>n</em> 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p><strong>说明：</strong></p>
<p>你必须在<strong><a href=""https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"" target=""_blank"">原地</a></strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p>
<p><strong>示例 1:</strong></p>
<pre>给定 <strong>matrix</strong> = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

<strong>原地</strong>旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
</pre>
<p><strong>示例 2:</strong></p>
<pre>给定 <strong>matrix</strong> =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

<strong>原地</strong>旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
</pre>
</div></div>"
49,Group Anagrams,https://leetcode.com/problems/group-anagrams/description/,Medium,39.2%,Group Anagrams,字母异位词分组,https://leetcode-cn.com/problems/group-anagrams/description/,中等,43.9%,Group Anagrams,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> <code>[""eat"", ""tea"", ""tan"", ""ate"", ""nat"", ""bat""]</code>,
<strong>输出:</strong>
[
  [""ate"",""eat"",""tea""],
  [""nat"",""tan""],
  [""bat""]
]</pre>
<p><strong>说明：</strong></p>
<ul>
<li>所有输入均为小写字母。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
</div></div>"
50,"Pow(x, n)",https://leetcode.com/problems/powx-n/description/,Medium,26.2%,"Pow(x, n)","Pow(x, n)",https://leetcode-cn.com/problems/powx-n/description/,中等,24.7%,"Pow(x, n)","<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>实现 <a href=""https://www.cplusplus.com/reference/valarray/pow/"" target=""_blank"">pow(<em>x</em>, <em>n</em>)</a> ，即计算 x 的 n 次幂函数。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 2.00000, 10
<strong>输出:</strong> 1024.00000
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 2.10000, 3
<strong>输出:</strong> 9.26100
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong> 2.00000, -2
<strong>输出:</strong> 0.25000
<strong>解释:</strong> 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25</pre>
<p><strong>说明:</strong></p>
<ul>
<li>-100.0 &lt; <em>x</em> &lt; 100.0</li>
<li><em>n</em> 是 32 位有符号整数，其数值范围是 [−2<sup>31</sup>, 2<sup>31 </sup>− 1] 。</li>
</ul>
</div></div>"
51,N-Queens,https://leetcode.com/problems/n-queens/description/,Hard,33.7%,N-Queens,N皇后,https://leetcode-cn.com/problems/n-queens/description/,困难,47.9%,N-Queens,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p><em>n </em>皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src=""/static/images/problemset/8-queens.png""/></p>
<p><small>上图为 8 皇后问题的一种解法。</small></p>
<p>给定一个整数 <em>n</em>，返回所有不同的 <em>n </em>皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 <em>n</em> 皇后问题的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> 4
<strong>输出:</strong> [
 ["".Q.."",  // 解法 1
  ""...Q"",
  ""Q..."",
  ""..Q.""],

 [""..Q."",  // 解法 2
  ""Q..."",
  ""...Q"",
  "".Q..""]
]
<strong>解释:</strong> 4 皇后问题存在两个不同的解法。
</pre>
</div></div>"
52,N-Queens II,https://leetcode.com/problems/n-queens-ii/description/,Hard,47.2%,N-Queens II,N皇后 II,https://leetcode-cn.com/problems/n-queens-ii/description/,困难,66.0%,N-Queens II,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p><em>n </em>皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src=""/static/images/problemset/8-queens.png""/></p>
<p><small>上图为 8 皇后问题的一种解法。</small></p>
<p>给定一个整数 <em>n</em>，返回 <em>n</em> 皇后不同的解决方案的数量。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> 4
<strong>输出:</strong> 2
<strong>解释:</strong> 4 皇后问题存在如下两个不同的解法。
[
 ["".Q.."",  // 解法 1
  ""...Q"",
  ""Q..."",
  ""..Q.""],

 [""..Q."",  // 解法 2
  ""Q..."",
  ""...Q"",
  "".Q..""]
]
</pre>
</div></div>"
53,Maximum Subarray,https://leetcode.com/problems/maximum-subarray/description/,Easy,40.5%,Maximum Subarray,最大子序和,https://leetcode-cn.com/problems/maximum-subarray/description/,简单,35.6%,Maximum Subarray,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> [-2,1,-3,4,-1,2,1,-5,4],
<strong>输出:</strong> 6
<strong>解释:</strong> 连续子数组 [4,-1,2,1] 的和最大，为 6。
</pre>
<p><strong>进阶:</strong></p>
<p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p>
</div></div>"
54,Spiral Matrix,https://leetcode.com/problems/spiral-matrix/description/,Medium,27.5%,Spiral Matrix,螺旋矩阵,https://leetcode-cn.com/problems/spiral-matrix/description/,中等,28.9%,Spiral Matrix,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个包含 <em>m</em> x <em>n</em> 个元素的矩阵（<em>m</em> 行, <em>n</em> 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong>
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
<strong>输出:</strong> [1,2,3,6,9,8,7,4,5]
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong>
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
<strong>输出:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]
</pre>
</div></div>"
55,Jump Game,https://leetcode.com/problems/jump-game/description/,Medium,29.7%,Jump Game,跳跃游戏,https://leetcode-cn.com/problems/jump-game/description/,中等,29.0%,Jump Game,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [2,3,1,1,4]
<strong>输出:</strong> true
<strong>解释:</strong> 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [3,2,1,0,4]
<strong>输出:</strong> false
<strong>解释:</strong> 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
</pre>
</div></div>"
56,Merge Intervals,https://leetcode.com/problems/merge-intervals/description/,Medium,32.3%,Merge Intervals,合并区间,https://leetcode-cn.com/problems/merge-intervals/description/,中等,29.7%,Merge Intervals,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [[1,3],[2,6],[8,10],[15,18]]
<strong>输出:</strong> [[1,6],[8,10],[15,18]]
<strong>解释:</strong> 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [[1,4],[4,5]]
<strong>输出:</strong> [[1,5]]
<strong>解释:</strong> 区间 [1,4] 和 [4,5] 可被视为重叠区间。</pre>
</div></div>"
57,Insert Interval,https://leetcode.com/problems/insert-interval/description/,Hard,29.2%,Insert Interval,插入区间,https://leetcode-cn.com/problems/insert-interval/description/,困难,25.7%,Insert Interval,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]
<strong>输出:</strong> [[1,5],[6,9]]
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> intervals = <code>[[1,2],[3,5],[6,7],[8,10],[12,16]]</code>, newInterval = <code>[4,8]</code>
<strong>输出:</strong> [[1,2],[3,10],[12,16]]
<strong>解释:</strong> 这是因为新的区间 <code>[4,8]</code> 与 <code>[3,5],[6,7],[8,10]</code> 重叠。
</pre>
</div></div>"
58,Length of Last Word,https://leetcode.com/problems/length-of-last-word/description/,Easy,32.1%,Length of Last Word,最后一个单词的长度,https://leetcode-cn.com/problems/length-of-last-word/description/,简单,28.2%,Length of Last Word,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个仅包含大小写字母和空格 <code>' '</code> 的字符串，返回其最后一个单词的长度。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<p><strong>说明：</strong>一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> ""Hello World""
<strong>输出:</strong> 5
</pre>
</div></div>"
59,Spiral Matrix II,https://leetcode.com/problems/spiral-matrix-ii/description/,Medium,41.5%,Spiral Matrix II,螺旋矩阵 II,https://leetcode-cn.com/problems/spiral-matrix-ii/description/,中等,55.2%,Spiral Matrix II,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个正整数 <em>n</em>，生成一个包含 1 到 <em>n</em><sup>2</sup> 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong> 3
<strong>输出:</strong>
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]</pre>
</div></div>"
60,Permutation Sequence,https://leetcode.com/problems/permutation-sequence/description/,Medium,29.8%,Permutation Sequence,第k个排列,https://leetcode-cn.com/problems/permutation-sequence/description/,中等,38.4%,Permutation Sequence,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给出集合 <code>[1,2,3,…,<em>n</em>]</code>，其所有元素共有 <em>n</em>! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 <em>n </em>= 3 时, 所有排列如下：</p>
<ol>
<li><code>""123""</code></li>
<li><code>""132""</code></li>
<li><code>""213""</code></li>
<li><code>""231""</code></li>
<li><code>""312""</code></li>
<li><code>""321""</code></li>
</ol>
<p>给定 <em>n</em> 和 <em>k</em>，返回第 <em>k</em> 个排列。</p>
<p><strong>说明：</strong></p>
<ul>
<li>给定<em> n</em> 的范围是 [1, 9]。</li>
<li>给定 <em>k </em>的范围是[1,  <em>n</em>!]。</li>
</ul>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> n = 3, k = 3
<strong>输出:</strong> ""213""
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> n = 4, k = 9
<strong>输出:</strong> ""2314""
</pre>
</div></div>"
61,Rotate List,https://leetcode.com/problems/rotate-list/description/,Medium,24.7%,Rotate List,旋转链表,https://leetcode-cn.com/problems/rotate-list/description/,中等,28.4%,Rotate List,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k </em>个位置，其中 <em>k </em>是非负数。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2
<strong>输出:</strong> 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
<strong>解释:</strong>
向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL
向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 0-&gt;1-&gt;2-&gt;NULL, k = 4
<strong>输出:</strong> <code>2-&gt;0-&gt;1-&gt;NULL</code>
<strong>解释:</strong>
向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL
向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL
向右旋转 3 步: <code>0-&gt;1-&gt;2-&gt;NULL</code>
向右旋转 4 步: <code>2-&gt;0-&gt;1-&gt;NULL</code></pre>
</div></div>"
62,Unique Paths,https://leetcode.com/problems/unique-paths/description/,Medium,43.2%,Unique Paths,不同路径,https://leetcode-cn.com/problems/unique-paths/description/,中等,47.2%,Unique Paths,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>一个机器人位于一个 <em>m x n </em>网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img src=""/static/images/problemset/robot_maze.png""/></p>
<p><small>例如，上图是一个7 x 3 的网格。有多少可能的路径？</small></p>
<p><strong>说明：</strong><em>m</em> 和 <em>n </em>的值均不超过 100。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> m = 3, n = 2
<strong>输出:</strong> 3
<strong>解释:</strong>
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -&gt; 向右 -&gt; 向下
2. 向右 -&gt; 向下 -&gt; 向右
3. 向下 -&gt; 向右 -&gt; 向右
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> m = 7, n = 3
<strong>输出:</strong> 28</pre>
</div></div>"
63,Unique Paths II,https://leetcode.com/problems/unique-paths-ii/description/,Medium,32.3%,Unique Paths II,不同路径 II,https://leetcode-cn.com/problems/unique-paths-ii/description/,中等,29.0%,Unique Paths II,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>一个机器人位于一个 <em>m x n </em>网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p><img src=""/static/images/problemset/robot_maze.png""/></p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><strong>说明：</strong><em>m</em> 和 <em>n </em>的值均不超过 100。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:
</strong>[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
<strong>输出:</strong> 2
<strong>解释:</strong>
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 <code>2</code> 条不同的路径：
1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右
</pre>
</div></div>"
64,Minimum Path Sum,https://leetcode.com/problems/minimum-path-sum/description/,Medium,41.3%,Minimum Path Sum,最小路径和,https://leetcode-cn.com/problems/minimum-path-sum/description/,中等,54.6%,Minimum Path Sum,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong>每次只能向下或者向右移动一步。</p>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong>
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
<strong>输出:</strong> 7
<strong>解释:</strong> 因为路径 1→3→1→1→1 的总和最小。
</pre>
</div></div>"
65,Valid Number,https://leetcode.com/problems/valid-number/description/,Hard,13.0%,Valid Number,有效数字,https://leetcode-cn.com/problems/valid-number/description/,困难,9.4%,Valid Number,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>验证给定的字符串是否为数字。</p>
<p>例如:<br/>
<code>""0""</code> =&gt; <code>true</code><br/>
<code>"" 0.1 ""</code> =&gt; <code>true</code><br/>
<code>""abc""</code> =&gt; <code>false</code><br/>
<code>""1 a""</code> =&gt; <code>false</code><br/>
<code>""2e10""</code> =&gt; <code>true</code></p>
<p><strong>说明:</strong> 我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。</p>
<p><strong>更新于 2015-02-10:</strong><br/>
<code>C++</code>函数的形式已经更新了。如果你仍然看见你的函数接收 <code>const char *</code> 类型的参数，请点击重载按钮重置你的代码。</p>
</div></div>"
66,Plus One,https://leetcode.com/problems/plus-one/description/,Easy,39.8%,Plus One,加一,https://leetcode-cn.com/problems/plus-one/description/,简单,35.0%,Plus One,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个<strong>非负整数</strong>组成的<strong>非空</strong>数组，在该数的基础上加一，返回一个新的数组。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> [1,2,3]
<strong>输出:</strong> [1,2,4]
<strong>解释:</strong> 输入数组表示数字 123。
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> [4,3,2,1]
<strong>输出:</strong> [4,3,2,2]
<strong>解释:</strong> 输入数组表示数字 4321。
</pre>
</div></div>"
67,Add Binary,https://leetcode.com/problems/add-binary/description/,Easy,34.5%,Add Binary,二进制求和,https://leetcode-cn.com/problems/add-binary/description/,简单,38.2%,Add Binary,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为<strong>非空</strong>字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> a = ""11"", b = ""1""
<strong>输出:</strong> ""100""</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> a = ""1010"", b = ""1011""
<strong>输出:</strong> ""10101""</pre>
</div></div>"
68,Text Justification,https://leetcode.com/problems/text-justification/description/,Hard,20.3%,Text Justification,文本左右对齐,https://leetcode-cn.com/problems/text-justification/description/,困难,24.5%,Text Justification,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>给定一个单词数组和一个长度 <em>maxWidth</em>，重新排版单词，使其成为每行恰好有 <em>maxWidth</em> 个字符，且左右两端对齐的文本。</p>
<p>你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 <code>' '</code> 填充，使得每行恰好有 <em>maxWidth</em> 个字符。</p>
<p>要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。</p>
<p>文本的最后一行应为左对齐，且单词之间不插入<strong>额外的</strong>空格。</p>
<p><strong>说明:</strong></p>
<ul>
<li>单词是指由非空格字符组成的字符序列。</li>
<li>每个单词的长度大于 0，小于等于 <em>maxWidth</em>。</li>
<li>输入单词数组 <code>words</code> 至少包含一个单词。</li>
</ul>
<p><strong>示例:</strong></p>
<pre><strong>输入:</strong>
words = [""This"", ""is"", ""an"", ""example"", ""of"", ""text"", ""justification.""]
maxWidth = 16
<strong>输出:</strong>
[
   ""This    is    an"",
   ""example  of text"",
   ""justification.  ""
]
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong>
words = [""What"",""must"",""be"",""acknowledgment"",""shall"",""be""]
maxWidth = 16
<strong>输出:</strong>
[
  ""What   must   be"",
  ""acknowledgment  "",
  ""shall be        ""
]
<strong>解释: </strong>注意最后一行的格式应为 ""shall be    "" 而不是 ""shall     be"",
     因为最后一行应为左对齐，而不是左右两端对齐。       
     第二行同样为左对齐，这是因为这行只包含一个单词。
</pre>
<p><strong>示例 3:</strong></p>
<pre><strong>输入:</strong>
words = [""Science"",""is"",""what"",""we"",""understand"",""well"",""enough"",""to"",""explain"",
         ""to"",""a"",""computer."",""Art"",""is"",""everything"",""else"",""we"",""do""]
maxWidth = 20
<strong>输出:</strong>
[
  ""Science  is  what we"",
  ""understand      well"",
  ""enough to explain to"",
  ""a  computer.  Art is"",
  ""everything  else  we"",
  ""do                  ""
]
</pre>
</div></div>"
69,Sqrt(x),https://leetcode.com/problems/sqrtx/description/,Easy,29.1%,Sqrt(x),x 的平方根,https://leetcode-cn.com/problems/sqrtx/description/,简单,30.2%,Sqrt(x),"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>实现 <code>int sqrt(int x)</code> 函数。</p>
<p>计算并返回 <em>x</em> 的平方根，其中 <em>x </em>是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 4
<strong>输出:</strong> 2
</pre>
<p><strong>示例 2:</strong></p>
<pre><strong>输入:</strong> 8
<strong>输出:</strong> 2
<strong>说明:</strong> 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
</pre>
</div></div>"
70,Climbing Stairs,https://leetcode.com/problems/climbing-stairs/description/,Easy,41.5%,Climbing Stairs,爬楼梯,https://leetcode-cn.com/problems/climbing-stairs/description/,简单,40.6%,Climbing Stairs,"<div class=""question-description__3U1T"" style=""padding-top: 10px;""><div class=""translation-tool__3Ffj""><span aria-hidden=""true"" class="""" data-original-title=""显示英文"" data-placement=""left"" data-toggle=""tooltip"" style=""cursor: pointer;""><div class=""switch-base__1Zql"" data-on=""false""><div class=""toggle__3ZBJ""></div></div></span></div><div><p>假设你正在爬楼梯。需要 <em>n</em> 步你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong> 2
<strong>输出：</strong> 2
<strong>解释：</strong> 有两种方法可以爬到楼顶。
1.  1 步 + 1 步
2.  2 步</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong> 3
<strong>输出：</strong> 3
<strong>解释：</strong> 有三种方法可以爬到楼顶。
1.  1 步 + 1 步 + 1 步
2.  1 步 + 2 步
3.  2 步 + 1 步
</pre>
</div></div>"
